<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel Drawing</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background-color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }

    /* Fixed drawing area */
    #drawingArea {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1200px;
      height: 850px;
      border: 1px solid #000;
      background: #fff;
      overflow: hidden;
    }

    #drawingArea canvas { display: block; }

    /* 4 small arrows to help center the drawing (clickable) */
    .centerArrow {
      position: absolute;
      font-size: 18px;
      color: #000;
      opacity: 0.5;
      cursor: pointer;
      pointer-events: auto;
      user-select: none;
    }
    .arrowTop    { top: 4px;    left: 50%; transform: translateX(-50%); }
    .arrowBottom { bottom: 4px; left: 50%; transform: translateX(-50%) rotate(180deg); }
    .arrowLeft   { left: 4px;   top: 50%;  transform: translateY(-50%) rotate(-90deg); }
    .arrowRight  { right: 4px;  top: 50%;  transform: translateY(-50%) rotate(90deg); }

    /* HTML overlay for line labels */
    #labelsOverlay {
      position: absolute;
      left: 0; top: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 15;
    }
    .lineLabel {
      position: absolute;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      color: #000;
      white-space: nowrap;
      pointer-events: auto;
      user-select: none;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(255,255,255,.9);
      padding: 10px 10px;
      border-radius: 10px;
      box-shadow: 0 1px 6px rgba(0,0,0,.06);
      width: 320px;
      max-height: calc(100vh - 20px);
      overflow: auto;
    }

    #zoomSliderContainer {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      z-index: 20;
      pointer-events: none;
    }
    #zoomSlider { width: 50%; pointer-events: auto; }

    #iconUploader, #textControls, #labelControls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      background: rgba(255,255,255,.9);
      padding: 6px 8px;
      border-radius: 8px;
      box-shadow: 0 1px 6px rgba(0,0,0,.06);
      width: 240px;
    }
    #textControls { top: 140px; }
    #labelControls { top: 270px; }

    /* Action bar: 2 buttons per row */
    #actionBar {
      position: fixed;
      right: 10px;
      top: 360px;
      z-index: 21;
      display: grid;
      grid-template-columns: repeat(2, max-content);
      grid-auto-rows: auto;
      gap: 6px 10px;
      align-items: center;
      background: rgba(255,255,255,.9);
      padding: 6px 8px;
      border-radius: 10px;
      box-shadow: 0 1px 6px rgba(0,0,0,.08);
    }
    #actionBar button { white-space: nowrap; }

    #textControls button,
    #iconUploader button,
    #labelControls button { margin-right: 5px; }

    .icon {
      position: absolute;
      width: 100px; height: 100px;
      z-index: 22;
      border: 0px dashed #000;
      transform-origin: center center;
    }
    .icon img { width: 100%; height: 100%; object-fit: contain; }

    .textContainer {
      position: absolute;
      padding: 5px;
      z-index: 22;
      border: 0px dashed #000;
      transform-origin: center center;
      background: transparent;
    }
    .textElement {
      font-size: 20px;
      white-space: pre-wrap;
      line-height: 1.2;
    }

    /* Inputs for fractions */
    #partNumber,
    #width, #length, #thickness,
    #lineLengthY, #distanceFromX,
    #lineLengthX, #distanceFromY,
    #iconSize, #textSize { width: 120px; }

    #lineType { width: 240px; }

    #notes {
      width: 100%;
      min-height: 70px;
      margin-top: 6px;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 8px;
      resize: vertical;
    }

    .selected { outline: 3px solid #216cff; border-radius: 6px; }

    .textContainer, .icon {
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      cursor: grab;
    }
    .dragging { cursor: grabbing; }

    /* ---- Local DB panel (SheetJS) ---- */
    #dbPanel {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid rgba(0,0,0,.12);
    }

    #dbPanel .row {
      display: flex;
      gap: 6px;
      align-items: center;
      margin: 6px 0;
    }

    #dbPanel input[type="text"] {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid rgba(0,0,0,.2);
      border-radius: 8px;
      outline: none;
    }

    #dbPanel button {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid rgba(0,0,0,.2);
      background: #fff;
      cursor: pointer;
    }
    #dbPanel button:active { transform: translateY(1px); }

    #dbTableWrap {
      max-height: 240px;
      overflow: auto;
      border: 1px solid rgba(0,0,0,.12);
      border-radius: 10px;
      background: #fff;
    }

    #dbTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    #dbTable th, #dbTable td {
      padding: 6px 8px;
      border-bottom: 1px solid rgba(0,0,0,.08);
      vertical-align: middle;
    }

    #dbTable th {
      position: sticky;
      top: 0;
      background: #fafafa;
      border-bottom: 1px solid rgba(0,0,0,.12);
      text-align: left;
      z-index: 1;
    }

    #dbTable td.actions { white-space: nowrap; width: 1%; }
    #dbTable td.actions button { padding: 4px 8px; margin-right: 6px; }
  </style>
</head>
<body>
  <!-- Fixed drawing area (1200 x 850) -->
  <div id="drawingArea">
    <div id="labelsOverlay"></div>
    <!-- 4 small arrows to visually move the drawing -->
    <div class="centerArrow arrowTop">▲</div>
    <div class="centerArrow arrowBottom">▲</div>
    <div class="centerArrow arrowLeft">▲</div>
    <div class="centerArrow arrowRight">▲</div>
  </div>

  <div id="controls">
    <label>Part Number:
      <input type="text" id="partNumber" placeholder="e.g. P-12345">
    </label><br><br>

    <label>Length: <input type="text" id="width" value="48"></label><br>
    <label>Width: <input type="text" id="length" value="36"></label><br>
    <label>Thickness: <input type="text" id="thickness" value="1"></label><br><br>

    <label>Panel Preset:
      <select id="panelPreset">
        <option value="custom">Custom (manual)</option>
        <option value="48x48x1">48 × 48 × 1</option>
        <option value="48x96x1">48 × 96 × 1</option>
        <option value="96x48x1">96 × 48 × 1</option>
        <option value="96x96x2">96 × 96 × 2</option>
      </select>
    </label><br><br>

    <label>Run Direction:
      <select id="runDirection">
        <option value="none">None</option>
        <option value="xPlus">Along length →</option>
        <option value="xMinus">Along length ←</option>
        <option value="yPlus">Along width ↑</option>
        <option value="yMinus">Along width ↓</option>
      </select>
    </label><br><br>

    <label>Width Lines:
      <select id="layoutPresetWidth">
        <option value="none">— Width layout —</option>
        <option value="bands2">2 bands (width)</option>
        <option value="bands3">3 bands (width)</option>
        <option value="bands4">4 bands (width)</option>
        <option value="bands5">5 bands (width)</option>
        <option value="bands6">6 bands (width)</option>
        <option value="bands7">7 bands (width)</option>
        <option value="bands8">8 bands (width)</option>
        <option value="bands9">9 bands (width)</option>
        <option value="bands10">10 bands (width)</option>
        <option value="bands12">12 bands (width)</option>
        <option value="bands15">15 bands (width)</option>
        <option value="bands24">24 bands (width)</option>
      </select>
    </label><br>

    <label>Length Lines:
      <select id="layoutPresetLength">
        <option value="none">— Length layout —</option>
        <option value="bands2">2 bands (length)</option>
        <option value="bands3">3 bands (length)</option>
        <option value="bands4">4 bands (length)</option>
        <option value="bands5">5 bands (length)</option>
        <option value="bands6">6 bands (length)</option>
        <option value="bands7">7 bands (length)</option>
        <option value="bands8">8 bands (length)</option>
        <option value="bands9">9 bands (length)</option>
        <option value="bands10">10 bands (length)</option>
        <option value="bands12">12 bands (length)</option>
        <option value="bands15">15 bands (length)</option>
        <option value="bands24">24 bands (length)</option>
      </select>
    </label><br><br>

    <label>Cut Style:
      <select id="lineType">
        <optgroup label="— Line Styles —">
          <option value="solid">Slit</option>
          <option value="dot">Dot</option>
          <option value="shortDash">Short Dash</option>
          <option value="longDash">Long Dash</option>
          <option value="shortDashDot">Short Dash + Dot</option>
          <option value="longDashDot">Long Dash + Dot</option>
          <option value="shortDash2Dot">Short Dash + 2 Dots</option>
          <option value="longDash2Dot">Long Dash + 2 Dots</option>
        </optgroup>
        <optgroup label="— Shapes on Line —">
          <option value="circle1">Line with 1 Circle</option>
          <option value="circle2">Line with 2 Circles</option>
          <option value="circle3">Line with 3 Circles</option>
          <option value="circle4">Line with 4 Circles</option>
          <option value="triangle1">Line with 1 Triangle</option>
          <option value="triangle2">Line with 2 Triangles</option>
          <option value="triangle3">Line with 3 Triangles</option>
          <option value="triangle4">Line with 4 Triangles</option>
          <option value="square1">Line with 1 Square</option>
          <option value="square2">Line with 2 Squares</option>
          <option value="square3">Line with 3 Squares</option>
          <option value="square4">Line with 4 Squares</option>
        </optgroup>
        <optgroup label="— Symbol Styles —">
          <option value="waterTrigram">☵ Water Trigram</option>
          <option value="mountainTrigram">☶ Mountain Trigram</option>
          <option value="earthTrigram">☷ Earth Trigram</option>
          <option value="yangMonogram">⚍ Yang Monogram</option>
          <option value="yinMonogram">⚏ Yin Monogram</option>
          <option value="recycleSymbol">♻ Recycling Symbol</option>
          <option value="arrowhead">➤ Arrowhead</option>
          <option value="concaveArrow">➨ Concave Arrow</option>
          <option value="doubleAngle">» Double Angle</option>
          <option value="doubleBar">‖ Double Bar</option>

          <option value="diamondArrow">◇─◆─ Pattern</option>
          <option value="crossCross">◈━◈━ Pattern</option>
          <option value="crossDiamond">◈━◆━ Pattern</option>
          <option value="diamondLine">◇─ Line</option>
          <option value="squareLine">◆─ Line</option>
          <option value="heavyDoubleLine">═══ Heavy Line</option>
          <option value="arrowRightLine">──▶ Right Arrow Line</option>
          <option value="arrowLeftLine">◀── Left Arrow Line</option>
        </optgroup>
      </select>
    </label><br><br>

    <label>Line Width: <input type="text" id="lineLengthY" value="48"></label><br>
    <label>Distance From Width: <input type="text" id="distanceFromX" value="4"></label><br>
    <button type="button" onclick="addYtoYLine()">Add Width Line</button><br><br>

    <label>Line Length: <input type="text" id="lineLengthX" value="36"></label><br>
    <label>Distance From length: <input type="text" id="distanceFromY" value="4"></label><br>
    <button type="button" onclick="addXtoXLine()">Add Length Line</button>

    <br><br>
    <textarea id="notes" placeholder="Enter notes here..."></textarea>

    <!-- NEW: DB + Search + 3-column table -->
    <div id="dbPanel">
      <div class="row">
        <input id="dbSearch" type="text" placeholder="Search part number…">
      </div>

      <div class="row" style="margin-top:8px; gap:6px;">
        <button id="cloudConnectBtn" type="button">Connect Cloud</button>
        <button id="cloudDisconnectBtn" type="button">Disconnect</button>
        <span id="cloudStatus" style="font-size:12px;color:#555;">Cloud: <b id="cloudStatusText">Not connected</b></span>
      </div>

      <div class="row" style="margin-top:8px; gap:6px;">
        <button id="cloudSaveBtn" type="button">Save Current</button>
        <button id="cloudLoadBtn" type="button">Load by Part #</button>
      </div>

      <div id="dbTableWrap" aria-label="Saved drawings">
        <table id="dbTable">
          <thead>
            <tr>
              <th style="width:60%;">Part Number</th>
              <th style="width:20%;">Edit</th>
              <th style="width:20%;">Delete</th>
            </tr>
          </thead>
          <tbody id="dbTbody"></tbody>
        </table>
      </div>

      <div class="row" style="margin-top:8px;">
        <button id="exportXlsxBtn" type="button">Export XLSX</button>
        <button id="importXlsxBtn" type="button">Import XLSX</button>
        <input id="importXlsxInput" type="file" accept=".xlsx,.xls" style="display:none">
      </div>
    </div>
  </div>

  <div id="zoomSliderContainer">
    <input type="range" id="zoomSlider" min="0" max="100" value="40">
  </div>

  <div id="iconUploader">
    <input type="file" id="uploadIcon" accept="image/*"><br>
    <button id="rotateIconButton" type="button">Rotate Icon</button>
    <button id="deleteIconButton" type="button">Delete Icon</button><br>
    <label for="iconSize">Icon Size: </label>
    <input type="number" id="iconSize" value="50" step="10"> px<br>
  </div>

  <div id="textControls">
    <label for="textInput">Text:</label><br>
    <textarea id="textInput" rows="4" cols="26" placeholder="Enter multi-line text..."></textarea><br>
    <label for="textSize">Text Size: </label>
    <input type="number" id="textSize" value="12" step="1"><br>
    <button id="addTextButton" type="button">Add Text</button><br>
    <button id="rotateTextButton" type="button">Rotate Text</button>
    <button id="deleteTextButton" type="button">Delete Text</button>
  </div>

  <!-- Hidden file input for loading state -->
  <input type="file" id="loadStateInput" accept=".json,.txt" style="display:none">

  <!-- Fixed action bar -->
  <div id="actionBar" role="toolbar" aria-label="Drawing actions">
    <button id="undoButton" type="button">Undo</button>
    <button id="redoButton" type="button">Redo</button>
    <button id="clearButton" type="button">Clear All</button>
    <button id="exportButton" type="button">Export as JPEG</button>
    <button id="saveStateButton" type="button">Save Drawing</button>
    <button id="loadStateButton" type="button">Load Drawing</button>
    <button id="exportSpecJsonButton" type="button">Export Spec JSON</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

  <script>
    const DRAW_WIDTH  = 1200;
    const DRAW_HEIGHT = 850;

    // camera view offset so arrows can move the drawing
    let viewOffsetX = 0;
    let viewOffsetY = 0;
    const VIEW_STEP  = 0.5;

    let scene, camera, renderer, wireframeBox, lineGroup, shapeGroup, dimensionGroup, runDirectionGroup;
    const drawingArea      = document.getElementById('drawingArea');
    const labelsOverlayDom = document.getElementById('labelsOverlay');

    const partNumberInput   = document.getElementById('partNumber');
    const widthInput        = document.getElementById('width');
    const lengthInput       = document.getElementById('length');
    const thicknessInput    = document.getElementById('thickness');
    const lineLengthYInput  = document.getElementById('lineLengthY');
    const distanceFromXInput= document.getElementById('distanceFromX');
    const lineLengthXInput  = document.getElementById('lineLengthX');
    const distanceFromYInput= document.getElementById('distanceFromY');
    const zoomSlider        = document.getElementById('zoomSlider');
    const notesInput        = document.getElementById('notes');

    let selectedElement = null;
    let rotationAngle = 0;

    const history   = [];
    const redoStack = [];
    const linesModel = []; // { kind: 'Y'|'X', lineLength, distance, lineType }
    const htmlLabels = []; // { text,pos3,start3,end3,flipLabel,el,styleKey }

    const LINE_COLOR = 0x000000;
    const LINE_STYLES = {
      solid:         { mode: 'solid' },
      shortDash:     { mode: 'dash',    dash: 1.0,  gap: 0.6 },
      longDash:      { mode: 'dash',    dash: 2.4,  gap: 0.8 },
      dot:           { mode: 'dot',     dotRadius: 0.15, dotSpacing: 0.8 },
      shortDashDot:  { mode: 'dashdot', dash: 1.0,  gap: 0.8, dotRadius: 0.15 },
      longDashDot:   { mode: 'dashdot', dash: 3,    gap: 1,   dotRadius: 0.15 },
      shortDash2Dot: { mode: 'dash2dot',dash: 1.0,  gap: 1.7, dotRadius: 0.15 },
      longDash2Dot:  { mode: 'dash2dot',dash: 3,    gap: 2,   dotRadius: 0.15 },
    };

    const STYLE_LABELS = {
      solid:        'Slit',
      dot:          'Dot',
      shortDash:    'Short Dash',
      longDash:     'Long Dash',
      shortDashDot: 'Short Dash + Dot',
      longDashDot:  'Long Dash + Dot',
      shortDash2Dot:'Short Dash + 2 Dots',
      longDash2Dot: 'Long Dash + 2 Dots',

      circle1:   'Circle 1',
      circle2:   'Circle 2',
      circle3:   'Circle 3',
      circle4:   'Circle 4',
      triangle1: 'Triangle 1',
      triangle2: 'Triangle 2',
      triangle3: 'Triangle 3',
      triangle4: 'Triangle 4',
      square1:   'Square 1',
      square2:   'Square 2',
      square3:   'Square 3',
      square4:   'Square 4',

      waterTrigram:    '☵ Water Trigram',
      mountainTrigram: '☶ Mountain Trigram',
      earthTrigram:    '☷ Earth Trigram',
      yangMonogram:    '⚍ Yang Monogram',
      yinMonogram:     '⚏ Yin Monogram',
      recycleSymbol:   '♻ Recycling Symbol',
      arrowhead:       '➤ Arrowhead',
      concaveArrow:    '➨ Concave Arrow',
      doubleAngle:     '» Double Angle',
      doubleBar:       '‖ Double Bar',

      diamondArrow:     '◇─◆─ Pattern',
      crossCross:       '◈━◈━ Pattern',
      crossDiamond:     '◈━◆━ Pattern',
      diamondLine:      '◇─ Line',
      squareLine:       '◆─ Line',
      heavyDoubleLine:  '═══ Heavy Line',
      arrowRightLine:   '──▶ Right Arrow Line',
      arrowLeftLine:    '◀── Left Arrow Line'
    };

    const PANEL_PRESETS = {
      '48x48x1': { width: 48, length: 48, thickness: 1 },
      '48x96x1': { width: 48, length: 96, thickness: 1 },
      '96x48x1': { width: 96, length: 48, thickness: 1 },
      '96x96x2': { width: 96, length: 96, thickness: 2 }
    };

    const SYMBOL_STYLES = {
      waterTrigram:    '☵',
      mountainTrigram: '☶',
      earthTrigram:    '☷',
      yangMonogram:    '⚍',
      yinMonogram:     '⚏',
      recycleSymbol:   '♻',
      arrowhead:       '➤',
      concaveArrow:    '➨',
      doubleAngle:     '»',
      doubleBar:       '‖',

      diamondArrow:    '◇─◆─',
      crossCross:      '◈━◈━',
      crossDiamond:    '◈━◆━',
      diamondLine:     '◇─',
      squareLine:      '◆─',
      heavyDoubleLine: '═══',
      arrowRightLine:  '──▶',
      arrowLeftLine:   '◀──'
    };

    const symbolTextures = {};

    // Run-direction arrow rotation state
    let runDirectionRotationDeg = 0;
    let runDirectionSprite = null;
    let runDirectionSprites = [];
    let runDirectionCenter3D = null;
    let isRotatingRunDir = false;
    let dragStartAngleScreen = 0;
    let dragStartRotationDeg = 0;

    
    /* ===== Cloud DB (Supabase) + SheetJS XLSX =====
       Table: drawings
       Columns:
         - part_number (text, primary key)
         - state_json  (text)
         - updated_at  (timestamptz)
    =============================================== */

    // Cloud UI
    const cloudConnectBtn    = document.getElementById('cloudConnectBtn');
    const cloudDisconnectBtn = document.getElementById('cloudDisconnectBtn');
    const cloudStatusText    = document.getElementById('cloudStatusText');
    const cloudSaveBtn       = document.getElementById('cloudSaveBtn');
    const cloudLoadBtn       = document.getElementById('cloudLoadBtn');

    // Supabase client (created from stored config)
    let sb = null;

    function getCloudConfig() {
      return {
        url: localStorage.getItem('PANEL_SUPABASE_URL') || '',
        key: localStorage.getItem('PANEL_SUPABASE_ANON_KEY') || ''
      };
    }
    function setCloudConfig(url, key) {
      localStorage.setItem('PANEL_SUPABASE_URL', (url || '').trim());
      localStorage.setItem('PANEL_SUPABASE_ANON_KEY', (key || '').trim());
    }
    function clearCloudConfig() {
      localStorage.removeItem('PANEL_SUPABASE_URL');
      localStorage.removeItem('PANEL_SUPABASE_ANON_KEY');
    }

    function ensureCloud() {
      const cfg = getCloudConfig();
      if (!cfg.url || !cfg.key) {
        sb = null;
        cloudStatusText.textContent = 'Not connected';
        return null;
      }
      try {
        sb = window.supabase.createClient(cfg.url, cfg.key);
        cloudStatusText.textContent = 'Connected';
        return sb;
      } catch (e) {
        console.error(e);
        sb = null;
        cloudStatusText.textContent = 'Not connected';
        return null;
      }
    }

    // In-memory cache for table rendering
    let dbCache = []; // [{ part_number, updated_at }]

    async function dbFetchList(filterText) {
      const client = ensureCloud();
      if (!client) return [];
      const term = (filterText || '').trim();

      let q = client.from('drawings')
        .select('part_number, updated_at')
        .order('part_number', { ascending: true })
        .limit(1000);

      if (term) q = q.ilike('part_number', `%${term}%`);

      const { data, error } = await q;
      if (error) { console.error(error); alert('Cloud list error: ' + error.message); return []; }
      dbCache = (data || []).filter(r => r.part_number);
      return dbCache;
    }

    async function dbGetState(partNumber) {
      const client = ensureCloud();
      if (!client) throw new Error('Cloud not connected');
      const { data, error } = await client.from('drawings')
        .select('state_json')
        .eq('part_number', partNumber)
        .maybeSingle();
      if (error) throw error;
      return data ? data.state_json : null;
    }

    async function dbUpsert(partNumber, stateJson) {
      const client = ensureCloud();
      if (!client) throw new Error('Cloud not connected');
      const payload = {
        part_number: partNumber,
        state_json: stateJson,
        updated_at: new Date().toISOString()
      };
      const { error } = await client.from('drawings').upsert(payload, { onConflict: 'part_number' });
      if (error) throw error;
    }

    async function dbRemove(partNumber) {
      const client = ensureCloud();
      if (!client) throw new Error('Cloud not connected');
      const { error } = await client.from('drawings').delete().eq('part_number', partNumber);
      if (error) throw error;
    }

    function sanitizePartNumber(pn) {
      return String(pn || '').trim();
    }

    async function renderDbTable(filterText) {
      const tbody = document.getElementById('dbTbody');
      tbody.innerHTML = '';

      const list = await dbFetchList(filterText);

      if (!list || list.length === 0) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td colspan="3" style="padding:10px;color:#777;">No records</td>`;
        tbody.appendChild(tr);
        return;
      }

      list.forEach((row) => {
        const pn = row.part_number;

        const tr = document.createElement('tr');

        const tdPart = document.createElement('td');
        tdPart.textContent = pn;
        tdPart.style.cursor = 'pointer';
        tdPart.title = 'Click to copy / set Part Number';
        tdPart.addEventListener('click', () => {
          navigator.clipboard?.writeText(pn).catch(()=>{});
          partNumberInput.value = pn;
        });

        const tdEdit = document.createElement('td');
        const editBtn = document.createElement('button');
        editBtn.textContent = 'Edit';
        editBtn.addEventListener('click', async () => {
          try {
            const json = await dbGetState(pn);
            if (!json) { alert('No drawing saved for: ' + pn); return; }
            restoreState(json);
            partNumberInput.value = pn;
            pushHistory();
          } catch (e) {
            console.error(e);
            alert('Load error: ' + (e.message || e));
          }
        });
        tdEdit.appendChild(editBtn);

        const tdDel = document.createElement('td');
        const delBtn = document.createElement('button');
        delBtn.textContent = 'Delete';
        delBtn.addEventListener('click', async () => {
          if (!confirm('Delete from cloud?\n' + pn)) return;
          try {
            await dbRemove(pn);
            await renderDbTable(dbSearchInput.value || '');
          } catch (e) {
            console.error(e);
            alert('Delete error: ' + (e.message || e));
          }
        });
        tdDel.appendChild(delBtn);

        tr.appendChild(tdPart);
        tr.appendChild(tdEdit);
        tr.appendChild(tdDel);
        tbody.appendChild(tr);
      });
    }

    // Search
    dbSearchInput.addEventListener('input', () => {
      renderDbTable(dbSearchInput.value || '');
    });

    // Export XLSX: exports the currently cached list (part numbers only)
    dbExportBtn.addEventListener('click', async () => {
      await renderDbTable(dbSearchInput.value || '');
      const data = (dbCache || []).map(r => ({ "Part Number": r.part_number }));
      const ws = XLSX.utils.json_to_sheet(data);
      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, ws, 'Parts');
      XLSX.writeFile(wb, 'parts.xlsx');
    });

    // Import XLSX: creates placeholders (state_json null) so they appear in the list
    dbImportBtn.addEventListener('click', () => dbImportInput.click());

    dbImportInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const client = ensureCloud();
        if (!client) { alert('Connect Cloud first.'); e.target.value = ''; return; }

        const buf = await file.arrayBuffer();
        const wb = XLSX.read(buf, { type: 'array' });
        const ws = wb.Sheets[wb.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });

        const partNumbers = rows
          .map(r => sanitizePartNumber(r["Part Number"] || r["part_number"] || r["Part"] || r["PartNumber"]))
          .filter(Boolean);

        if (partNumbers.length === 0) {
          alert('No "Part Number" column found.');
          e.target.value = '';
          return;
        }

        const payload = partNumbers.map(pn => ({
          part_number: pn,
          state_json: null,
          updated_at: new Date().toISOString()
        }));

        const { error } = await client.from('drawings').upsert(payload, { onConflict: 'part_number' });
        if (error) throw error;

        await renderDbTable(dbSearchInput.value || '');
        alert('Imported ' + partNumbers.length + ' parts.');
      } catch (err) {
        console.error(err);
        alert('Import error: ' + (err.message || err));
      } finally {
        e.target.value = '';
      }
    });

    // Cloud connect/disconnect + save/load helpers
    function connectCloudPrompt() {
      const current = getCloudConfig();
      const url = prompt('Supabase URL (Project Settings → API):', current.url || '');
      if (url === null) return;
      const key = prompt('Supabase ANON key (Project Settings → API):', current.key || '');
      if (key === null) return;
      setCloudConfig(url, key);
      ensureCloud();
      renderDbTable(dbSearchInput.value || '');
    }

    function disconnectCloud() {
      clearCloudConfig();
      ensureCloud();
      document.getElementById('dbTbody').innerHTML = `<tr><td colspan="3" style="padding:10px;color:#777;">No records</td></tr>`;
    }

    cloudConnectBtn.addEventListener('click', connectCloudPrompt);
    cloudDisconnectBtn.addEventListener('click', disconnectCloud);

    cloudSaveBtn.addEventListener('click', async () => {
      const pn = sanitizePartNumber(partNumberInput.value);
      if (!pn) { alert('Type a Part Number first.'); return; }
      try {
        await dbUpsert(pn, serializeState());
        await renderDbTable(dbSearchInput.value || '');
        alert('Saved to cloud: ' + pn);
      } catch (e) {
        console.error(e);
        alert('Save error: ' + (e.message || e));
      }
    });

    cloudLoadBtn.addEventListener('click', async () => {
      const pn = sanitizePartNumber(prompt('Part Number to load:', sanitizePartNumber(partNumberInput.value)));
      if (!pn) return;
      try {
        const json = await dbGetState(pn);
        if (!json) { alert('No drawing saved for: ' + pn); return; }
        restoreState(json);
        partNumberInput.value = pn;
        pushHistory();
      } catch (e) {
        console.error(e);
        alert('Load error: ' + (e.message || e));
      }
    });

    // Initialize cloud status + initial list render
    ensureCloud();
    renderDbTable('');


    /* --------- FRACTION HELPERS (inches) ---------- */
    function gcd(a, b) {
      a = Math.abs(a); b = Math.abs(b);
      if (a < 1e-8) return b || 1;
      if (b < 1e-8) return a || 1;
      while (b > 1e-8) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a || 1;
    }

    function parseInches(str) {
      if (str == null) return NaN;
      str = String(str).trim();
      if (!str) return NaN;
      str = str.replace(/"/g, '').trim();

      let sign = 1;
      if (str[0] === '+') { str = str.slice(1).trim(); }
      else if (str[0] === '-') { sign = -1; str = str.slice(1).trim(); }
      if (!str) return NaN;

      const parts = str.split(/\s+/);
      let whole = 0, frac = 0;

      if (parts.length === 1) {
        const p = parts[0];
        if (p.includes('/')) {
          const [n, d] = p.split('/');
          if (!d || isNaN(+d)) return NaN;
          frac = parseFloat(n) / parseFloat(d);
        } else {
          whole = parseFloat(p);
          if (isNaN(whole)) return NaN;
        }
      } else {
        const wPart = parts[0];
        whole = parseFloat(wPart);
        if (isNaN(whole)) return NaN;
        const fracPart = parts[1];
        if (fracPart.includes('/')) {
          const [n,d] = fracPart.split('/');
          if (!d || isNaN(+d)) return NaN;
          frac = parseFloat(n) / parseFloat(d);
        } else {
          const val2 = parseFloat(fracPart);
          if (!isNaN(val2)) frac = val2;
        }
      }
      return sign * (whole + frac);
    }

    function formatInches(val) {
      if (!isFinite(val)) return '';
      const sign = val < 0 ? '-' : '';
      let v = Math.abs(val);

      const epsilon = 1e-6;
      v = v + epsilon;

      let whole = Math.floor(v);
      let frac  = v - whole;

      const denomBase = 16;
      let num = Math.round(frac * denomBase);

      if (num === 0) return sign + whole;
      if (num === denomBase) { whole += 1; return sign + whole; }

      const g = gcd(num, denomBase);
      num /= g;
      const denom = denomBase / g;

      if (whole === 0) return `${sign}${num}/${denom}`;
      return `${sign}${whole} ${num}/${denom}`;
    }

    function formatInchesWithQuote(val) {
      const f = formatInches(val);
      return f ? f + '"' : '';
    }
    /* ---------------------------------------------- */

    function getSymbolTexture(symbolStr) {
      if (symbolTextures[symbolStr]) return symbolTextures[symbolStr];
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0,0,256,128);
      ctx.fillStyle = '#000000';
      ctx.font = '64px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(symbolStr, 128, 64);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      symbolTextures[symbolStr] = tex;
      return tex;
    }

    function drawStyledLine(start, end, styleKey) {
      const cfg = LINE_STYLES[styleKey] || LINE_STYLES.solid;
      const group = new THREE.Group();
      const dir = new THREE.Vector3().subVectors(end, start);
      const length = dir.length();
      if (length <= 0.0001) return group;
      dir.normalize();

      const lineMat = new THREE.LineBasicMaterial({ color: LINE_COLOR });
      const dotMat  = new THREE.MeshBasicMaterial({ color: LINE_COLOR });

      function dotMesh(r) {
        const geo = new THREE.SphereGeometry(r, 12, 12);
        return new THREE.Mesh(geo, dotMat);
      }
      function addSegment(t0, t1) {
        const p0 = start.clone().add(dir.clone().multiplyScalar(t0));
        const p1 = start.clone().add(dir.clone().multiplyScalar(t1));
        const g = new THREE.BufferGeometry().setFromPoints([p0, p1]);
        const seg = new THREE.Line(g, lineMat);
        group.add(seg);
      }
      function addDotsInGap(tGapStart, tGapEnd, n, r) {
        if (n <= 0) return;
        const span = tGapEnd - tGapStart;
        if (span <= 0) return;
        if (n === 1) {
          const t = tGapStart + span * 0.5;
          const p = start.clone().add(dir.clone().multiplyScalar(t));
          const m = dotMesh(r); m.position.copy(p); group.add(m);
        } else {
          const step = span / (n + 1);
          for (let i = 1; i <= n; i++) {
            const t = tGapStart + step * i;
            const p = start.clone().add(dir.clone().multiplyScalar(t));
            const m = dotMesh(r); m.position.copy(p); group.add(m);
          }
        }
      }

      switch (cfg.mode) {
        case 'solid': addSegment(0, length); break;
        case 'dash': {
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const t0 = t;
            const t1 = Math.min(t + cfg.dash, length);
            if (t1 > t0) addSegment(t0, t1);
          }
          break;
        }
        case 'dot': {
          const spacing = cfg.dotSpacing;
          const r = cfg.dotRadius;
          for (let t = 0; t <= length; t += spacing) {
            const p = start.clone().add(dir.clone().multiplyScalar(Math.min(t, length)));
            const m = dotMesh(r); m.position.copy(p); group.add(m);
          }
          break;
        }
        case 'dashdot': {
          const r = cfg.dotRadius;
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const d0 = t;
            const d1 = Math.min(t + cfg.dash, length);
            if (d1 > d0) addSegment(d0, d1);
            const g0 = d1;
            const g1 = Math.min(d1 + cfg.gap, length);
            addDotsInGap(g0, g1, 1, r);
          }
          break;
        }
        case 'dash2dot': {
          const r = cfg.dotRadius;
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const d0 = t;
            const d1 = Math.min(t + cfg.dash, length);
            if (d1 > d0) addSegment(d0, d1);
            const g0 = d1;
            const g1 = Math.min(d1 + cfg.gap, length);
            addDotsInGap(g0, g1, 2, r);
          }
          break;
        }
      }
      return group;
    }

    function getLabelDisplayText(key) {
      return STYLE_LABELS[key] || key;
    }

    function applyStyleLabelOverridesToSelect() {
      const select = document.getElementById('lineType');
      Array.from(select.options).forEach(opt => {
        const key = opt.value;
        if (STYLE_LABELS[key]) opt.textContent = STYLE_LABELS[key];
      });
    }

    function isVertical(start, end) {
      return Math.abs(start.x - end.x) < 1e-6 && Math.abs(start.z - end.z) > 1e-6;
    }

    function labelHasBackground(styleKey) {
      return true;
    }

    function clearHtmlLabels() {
      htmlLabels.forEach(l => l.el.remove());
      htmlLabels.length = 0;
    }

    function addLabel(displayText, position, isVert, styleKey, start, end, flipLabel) {
      const core   = (displayText || '').trim();
      const padded = '  ' + core + '  ';

      const label = document.createElement('div');
      label.className = 'lineLabel';
      label.textContent = padded;

      label.dataset.textCore   = core;
      label.dataset.styleKey   = styleKey || '';
      label.dataset.isVertical = isVert ? '1' : '0';

      if (labelHasBackground(styleKey)) {
        label.style.background = '#ffffff';
        label.style.border = '1px solid #ffffff';
        label.style.padding = '2px 8px';
      }

      label.addEventListener('dblclick', () => {
        const current = label.dataset.textCore || '';
        const updated = prompt('Edit label text:', current);
        if (updated !== null && updated.trim() !== current) {
          const newCore = updated.trim();
          label.dataset.textCore = newCore;
          label.textContent = '  ' + newCore + '  ';
        }
      });

      labelsOverlayDom.appendChild(label);

      const record = {
        text: core,
        pos3: position.clone(),
        start3: start.clone(),
        end3: end.clone(),
        flipLabel: !!flipLabel,
        el: label,
        styleKey: styleKey || ''
      };
      htmlLabels.push(record);
      updateOneHtmlLabel(record);
    }

    function updateOneHtmlLabel(lbl) {
      const rect = drawingArea.getBoundingClientRect();

      const mid = lbl.pos3.clone();
      mid.project(camera);
      const x = (mid.x + 1) / 2 * rect.width;
      const y = (-mid.y + 1) / 2 * rect.height;

      const s = lbl.start3.clone().project(camera);
      const e = lbl.end3.clone().project(camera);
      const sx = (s.x + 1) / 2 * rect.width;
      const sy = (-s.y + 1) / 2 * rect.height;
      const ex = (e.x + 1) / 2 * rect.width;
      const ey = (-e.y + 1) / 2 * rect.height;

      let angleRad = Math.atan2(ey - sy, ex - sx);
      if (lbl.flipLabel) angleRad += Math.PI;

      if (angleRad > Math.PI)  angleRad -= 2 * Math.PI;
      if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
      if (angleRad >  Math.PI / 2)  angleRad -= Math.PI;
      if (angleRad < -Math.PI / 2)  angleRad += Math.PI;

      const angleDeg = angleRad * 180 / Math.PI;

      lbl.el.style.left = x + 'px';
      lbl.el.style.top  = y + 'px';
      lbl.el.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
    }

    function updateAllHtmlLabels() {
      htmlLabels.forEach(updateOneHtmlLabel);
    }

    function addSymbolLine(symbolKey, start, end) {
      const symbolStr = SYMBOL_STYLES[symbolKey];
      if (!symbolStr) return;

      const tex = getSymbolTexture(symbolStr);
      const dir = new THREE.Vector3().subVectors(end, start);
      const length = dir.length();
      if (length <= 0.0001) return;
      dir.normalize();

      const spacing = 1.0;
      const halfSpacing = spacing / 2;
      let rotationRad = 6; // your previous choice

      for (let t = halfSpacing; t < length; t += spacing) {
        const pos = start.clone().add(dir.clone().multiplyScalar(t));
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
        const sprite = new THREE.Sprite(mat);
        sprite.position.copy(pos);
        const size = 2.0;
        sprite.scale.set(size, size, size);
        sprite.material.rotation = rotationRad;
        shapeGroup.add(sprite);
      }
    }

    function setupPanelLayoutPresets() {
      const panelSelect       = document.getElementById('panelPreset');
      const layoutWidthSelect = document.getElementById('layoutPresetWidth');
      const layoutLenSelect   = document.getElementById('layoutPresetLength');

      panelSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        const preset = PANEL_PRESETS[val];
        if (!preset) return;
        widthInput.value     = formatInchesWithQuote(preset.width);
        lengthInput.value    = formatInchesWithQuote(preset.length);
        thicknessInput.value = formatInchesWithQuote(preset.thickness);
        updateBox();
        pushHistory();
      });

      layoutWidthSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'none') return;

        const cubeWidth  = parseInches(widthInput.value);
        const cubeLength = parseInches(lengthInput.value);
        if (!cubeWidth || !cubeLength) {
          alert('Set panel dimensions first.');
          e.target.value = 'none';
          return;
        }
        const n = parseInt(val.replace('bands',''),10);
        if (!n || n < 2) { e.target.value = 'none'; return; }

        if (!confirm('Apply WIDTH layout preset and remove existing width lines?')) {
          e.target.value = 'none';
          return;
        }
        for (let i = linesModel.length - 1; i >= 0; i--) {
          if (linesModel[i].kind === 'Y') linesModel.splice(i,1);
        }
        const lineType = document.getElementById('lineType').value;
        const stepX = cubeWidth / n;
        for (let k=1;k<n;k++){
          const dist = k * stepX;
          linesModel.push({kind:'Y', lineLength:cubeLength, distance:dist, lineType});
        }
        rebuildLinesFromModel();
        e.target.value='none';
        pushHistory();
      });

      layoutLenSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'none') return;

        const cubeWidth  = parseInches(widthInput.value);
        const cubeLength = parseInches(lengthInput.value);
        if (!cubeWidth || !cubeLength) {
          alert('Set panel dimensions first.');
          e.target.value = 'none';
          return;
        }
        const n = parseInt(val.replace('bands',''),10);
        if (!n || n < 2) { e.target.value = 'none'; return; }

        if (!confirm('Apply LENGTH layout preset and remove existing length lines?')) {
          e.target.value = 'none';
          return;
        }
        for (let i = linesModel.length - 1; i >= 0; i--) {
          if (linesModel[i].kind === 'X') linesModel.splice(i,1);
        }
        const lineType = document.getElementById('lineType').value;
        const stepZ = cubeLength / n;
        for (let k=1;k<n;k++){
          const dist = k * stepZ;
          linesModel.push({kind:'X', lineLength:cubeWidth, distance:dist, lineType});
        }
        rebuildLinesFromModel();
        e.target.value='none';
        pushHistory();
      });
    }

    function applyCameraLook() {
      if (!camera) return;
      camera.lookAt(viewOffsetX, viewOffsetY, 0);
      camera.updateProjectionMatrix();
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(30, DRAW_WIDTH / DRAW_HEIGHT, 0.1, 1000);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(1);
      renderer.setSize(DRAW_WIDTH, DRAW_HEIGHT, false);
      drawingArea.appendChild(renderer.domElement);

      applyStyleLabelOverridesToSelect();
      createWireframeBox();

      lineGroup  = new THREE.Group();
      shapeGroup = new THREE.Group();
      dimensionGroup = new THREE.Group();
      runDirectionGroup = new THREE.Group();

      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);

      widthInput.addEventListener('input', updateBox);
      lengthInput.addEventListener('input', updateBox);
      thicknessInput.addEventListener('input', updateBox);
      zoomSlider.addEventListener('input', updateZoom);

      widthInput.addEventListener('change', pushHistory);
      lengthInput.addEventListener('change', pushHistory);
      thicknessInput.addEventListener('change', pushHistory);

      window.addEventListener('resize', onResize, false);
      setupHistoryButtons();
      setupSaveLoadButtons();
      setupPanelLayoutPresets();

      const runDirSelect = document.getElementById('runDirection');
      runDirSelect.addEventListener('change', () => {
        const val = runDirSelect.value;
        switch (val) {
          case 'xPlus':  runDirectionRotationDeg = 0;   break;
          case 'xMinus': runDirectionRotationDeg = 180; break;
          case 'yPlus':  runDirectionRotationDeg = 90;  break;
          case 'yMinus': runDirectionRotationDeg = -90; break;
          default:       runDirectionRotationDeg = 0;   break;
        }
        updateRunDirectionArrow();
        pushHistory();
      });

      // arrows pan
      const topArrow    = drawingArea.querySelector('.arrowTop');
      const bottomArrow = drawingArea.querySelector('.arrowBottom');
      const leftArrow   = drawingArea.querySelector('.arrowLeft');
      const rightArrow  = drawingArea.querySelector('.arrowRight');

      topArrow?.addEventListener('click', () => { viewOffsetY -= VIEW_STEP; applyCameraLook(); updateAllHtmlLabels(); });
      bottomArrow?.addEventListener('click', () => { viewOffsetY += VIEW_STEP; applyCameraLook(); updateAllHtmlLabels(); });
      leftArrow?.addEventListener('click', () => { viewOffsetX -= VIEW_STEP; applyCameraLook(); updateAllHtmlLabels(); });
      rightArrow?.addEventListener('click', () => { viewOffsetX += VIEW_STEP; applyCameraLook(); updateAllHtmlLabels(); });

      drawingArea.addEventListener('pointerdown', onRunDirPointerDown);
      document.addEventListener('pointermove', onRunDirPointerMove);
      document.addEventListener('pointerup', onRunDirPointerUp);
      document.addEventListener('pointercancel', onRunDirPointerUp);

      // DB UI hooks
      dbSearchInput.addEventListener('input', () => renderDbTable(dbSearchInput.value));
      exportXlsxBtn.addEventListener('click', exportDbToXlsx);
      importXlsxBtn.addEventListener('click', () => { importXlsxInp.value=''; importXlsxInp.click(); });
      importXlsxInp.addEventListener('change', (e) => {
        const f = e.target.files && e.target.files[0];
        if (f) importDbFromXlsxFile(f);
      });
      renderDbTable('');

      updateDimensions();
      updateRunDirectionArrow();
      frameCamera();
      animate();
      pushHistory();
    }

    function onResize() {
      camera.aspect = DRAW_WIDTH / DRAW_HEIGHT;
      camera.updateProjectionMatrix();
      updateAllHtmlLabels();
    }

    function createWireframeBox() {
      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      const geometry = new THREE.BoxGeometry(width, thickness, length);
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
      wireframeBox = new THREE.LineSegments(edges, lineMaterial);
      scene.add(wireframeBox);
    }

    function updateBox() {
      scene.remove(wireframeBox);
      createWireframeBox();
      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);
      updateDimensions();
      rebuildLinesFromModel();
      updateRunDirectionArrow();
      frameCamera();
    }

    function updateZoom() {
      const minDist = 50;
      const maxDist = 400;

      const sliderMin = parseFloat(zoomSlider.min);
      const sliderMax = parseFloat(zoomSlider.max);
      const sliderVal = parseFloat(zoomSlider.value);
      const t = (sliderVal - sliderMin) / (sliderMax - sliderMin);

      const dist = maxDist - t * (maxDist - minDist);

      const target = new THREE.Vector3(viewOffsetX, viewOffsetY, 0);
      const dir = camera.position.clone().sub(target).normalize();
      camera.position.copy(target.clone().add(dir.multiplyScalar(dist)));
      applyCameraLook();
      updateAllHtmlLabels();
    }

    function frameCamera() {
      const w = parseInches(widthInput.value)  || 1;
      const l = parseInches(lengthInput.value) || 1;

      const diag   = Math.sqrt(w * w + l * l);
      const radius = diag / 2;

      const fovRad = THREE.MathUtils.degToRad(camera.fov);
      const dist   = (radius / Math.sin(fovRad / 2)) * 1.2;

      const dir = new THREE.Vector3(1, 1, 1).normalize();
      const target = new THREE.Vector3(viewOffsetX, viewOffsetY, 0);
      camera.position.copy(target.clone().add(dir.multiplyScalar(dist)));
      applyCameraLook();
      updateAllHtmlLabels();
    }

    function updateDimensions() {
      if (!dimensionGroup) return;

      for (let i = htmlLabels.length - 1; i >= 0; i--) {
        if (htmlLabels[i].styleKey === 'dimW' || htmlLabels[i].styleKey === 'dimL') {
          htmlLabels[i].el.remove();
          htmlLabels.splice(i, 1);
        }
      }

      dimensionGroup.clear();

      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      if (!width || !length) return;

      const y = thickness + 0.5;
      const offset = 3;

      const arrowChar = SYMBOL_STYLES.arrowhead;
      const tex = getSymbolTexture(arrowChar);
      const arrowSize = 1.2;

      // WIDTH dimension
      const wStart = new THREE.Vector3(-width / 2, y, -length / 2 - offset);
      const wEnd   = new THREE.Vector3( width / 2, y, -length / 2 - offset);
      const wGeo   = new THREE.BufferGeometry().setFromPoints([wStart, wEnd]);
      const wMat   = new THREE.LineBasicMaterial({ color: 0x000000 });
      dimensionGroup.add(new THREE.Line(wGeo, wMat));

      const wMid = new THREE.Vector3().addVectors(wStart, wEnd).multiplyScalar(0.5);
      addLabel(formatInchesWithQuote(width), wMid, false, 'dimW', wStart, wEnd, false);

      const wDir = new THREE.Vector3().subVectors(wEnd, wStart).normalize();
      const insetW = 0.6;

      const spriteWStart = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
      spriteWStart.position.copy(wStart.clone().add(wDir.clone().multiplyScalar(insetW)));
      spriteWStart.scale.set(arrowSize, arrowSize, arrowSize);
      spriteWStart.material.rotation = Math.PI;
      dimensionGroup.add(spriteWStart);

      const spriteWEnd = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
      spriteWEnd.position.copy(wEnd.clone().add(wDir.clone().multiplyScalar(-insetW)));
      spriteWEnd.scale.set(arrowSize, arrowSize, arrowSize);
      spriteWEnd.material.rotation = 0;
      dimensionGroup.add(spriteWEnd);

      // LENGTH dimension
      const lStart = new THREE.Vector3(width / 2 + offset, y, -length / 2);
      const lEnd   = new THREE.Vector3(width / 2 + offset, y,  length / 2);
      const lGeo   = new THREE.BufferGeometry().setFromPoints([lStart, lEnd]);
      const lMat   = new THREE.LineBasicMaterial({ color: 0x000000 });
      dimensionGroup.add(new THREE.Line(lGeo, lMat));

      const lMid = new THREE.Vector3().addVectors(lStart, lEnd).multiplyScalar(0.5);
      addLabel(formatInchesWithQuote(length), lMid, true, 'dimL', lStart, lEnd, false);
    }

    function updateRunDirectionArrow() {
      if (!runDirectionGroup) return;
      runDirectionGroup.clear();
      runDirectionSprite = null;
      runDirectionSprites = [];
      runDirectionCenter3D = null;

      const mode = document.getElementById('runDirection').value;
      if (mode === 'none') return;

      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      if (!width || !length) return;

      const arrowChar = SYMBOL_STYLES.arrowhead;
      const tex = getSymbolTexture(arrowChar);

      const y = thickness + 1.0;
      const offsetZ = 3;
      const baseAlong = 0.8;

      const rightPos = new THREE.Vector3(width / 2 - baseAlong, y, -length / 2 - offsetZ);

      const size = 3.0;
      const rotRad = THREE.MathUtils.degToRad(runDirectionRotationDeg || 0);

      const spriteRight = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true }));
      spriteRight.position.copy(rightPos);
      spriteRight.scale.set(size, size, size);
      spriteRight.material.rotation = rotRad;

      runDirectionGroup.add(spriteRight);
      runDirectionSprite = spriteRight;
      runDirectionSprites = [spriteRight];
      runDirectionCenter3D = rightPos.clone();
    }

    // expose to buttons
    window.addYtoYLine = function addYtoYLine() {
      const distanceFromX = parseInches(distanceFromXInput.value);
      const lineType      = document.getElementById('lineType').value;
      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      if (!cubeWidth || !cubeLength || isNaN(distanceFromX)) return;

      const lineLengthY = cubeLength;
      lineLengthYInput.value = formatInchesWithQuote(cubeLength);

      linesModel.push({ kind: 'Y', lineLength: lineLengthY, distance: distanceFromX, lineType });

      const startX = -cubeWidth / 2 + distanceFromX;
      const startY = 0.5;
      const startZ = -cubeLength / 2;

      const start = new THREE.Vector3(startX, startY, startZ);
      const end   = new THREE.Vector3(startX, startY, startZ + lineLengthY);

      drawLineAndExtras(start, end, lineType, true);
      pushHistory();
    }

    window.addXtoXLine = function addXtoXLine() {
      const distanceFromY = parseInches(distanceFromYInput.value);
      const lineType      = document.getElementById('lineType').value;
      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      if (!cubeWidth || !cubeLength || isNaN(distanceFromY)) return;

      const lineLengthX = cubeWidth;
      lineLengthXInput.value = formatInchesWithQuote(cubeWidth);

      linesModel.push({ kind: 'X', lineLength: lineLengthX, distance: distanceFromY, lineType });

      const startX = -cubeWidth / 2;
      const startY = 0.5;
      const startZ = -cubeLength / 2 + distanceFromY;

      const start = new THREE.Vector3(startX, startY, startZ);
      const end   = new THREE.Vector3(startX + lineLengthX, startY, startZ);

      drawLineAndExtras(start, end, lineType, false);
      pushHistory();
    }

    function rebuildLinesFromModel() {
      lineGroup.clear();
      shapeGroup.clear();

      for (let i = htmlLabels.length - 1; i >= 0; i--) {
        if (htmlLabels[i].styleKey !== 'dimW' && htmlLabels[i].styleKey !== 'dimL') {
          htmlLabels[i].el.remove();
          htmlLabels.splice(i, 1);
        }
      }

      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      linesModel.forEach(l => {
        let start, end, flipLabel = false;

        if (l.kind === 'Y') {
          l.lineLength = cubeLength;

          const startX = -cubeWidth / 2 + l.distance;
          start = new THREE.Vector3(startX, 0.5, -cubeLength / 2);
          end   = new THREE.Vector3(startX, 0.5, -cubeLength / 2 + l.lineLength);

          flipLabel = true;
          drawLineAndExtras(start, end, l.lineType, flipLabel);
        } else if (l.kind === 'X') {
          l.lineLength = cubeWidth;

          const startZ = -cubeLength / 2 + l.distance;
          start = new THREE.Vector3(-cubeWidth / 2, 0.5, startZ);
          end   = new THREE.Vector3(-cubeWidth / 2 + l.lineLength, 0.5, startZ);

          flipLabel = false;
          drawLineAndExtras(start, end, l.lineType, flipLabel);
        }
      });

      if (linesModel.some(l => l.kind === 'Y')) lineLengthYInput.value = formatInchesWithQuote(cubeLength);
      if (linesModel.some(l => l.kind === 'X')) lineLengthXInput.value = formatInchesWithQuote(cubeWidth);
    }

    function drawLineAndExtras(start, end, lineType, flipLabel) {
      const isSymbolStyle = Object.prototype.hasOwnProperty.call(SYMBOL_STYLES, lineType);

      if (!isSymbolStyle) {
        if (lineType in LINE_STYLES) {
          const styled = drawStyledLine(start, end, lineType);
          lineGroup.add(styled);
        } else {
          const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
          const mat = new THREE.LineBasicMaterial({ color: 0x000000 });
          lineGroup.add(new THREE.Line(geo, mat));
        }
      }

      if (isSymbolStyle) {
        addSymbolLine(lineType, start, end);
      } else {
        addGroupedShapes(lineType, start.clone(), start.distanceTo(end), isVertical(start, end));
      }

      const vertical = isVertical(start, end);
      const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
      mid.y += 0.01;

      const labelText = getLabelDisplayText(lineType);
      addLabel(labelText, mid, vertical, lineType, start, end, flipLabel);
    }

    function addGroupedShapes(lineType, startPosition, lineLength, isVerticalLine) {
      let shapeCount;
      if (lineType.includes('circle'))      shapeCount = parseInt(lineType.replace('circle',''),10);
      else if (lineType.includes('triangle')) shapeCount = parseInt(lineType.replace('triangle',''),10);
      else if (lineType.includes('square'))   shapeCount = parseInt(lineType.replace('square',''),10);
      else return;

      const groupSize = shapeCount;
      const gapSize   = 1.5;
      const totalGroupSize = groupSize + gapSize;
      const numGroups = Math.floor(lineLength / totalGroupSize);
      const shapeSpacing = 0.9;

      for (let g=0; g<numGroups; g++) {
        const groupStart = g * totalGroupSize;
        for (let i=0; i<shapeCount; i++) {
          const pos = startPosition.clone();
          if (isVerticalLine) pos.z += groupStart + (i * shapeSpacing);
          else                pos.x += groupStart + (i * shapeSpacing);

          let shape;
          if (lineType.includes('circle'))      shape = createCircle();
          else if (lineType.includes('triangle')) shape = createTriangle();
          else if (lineType.includes('square'))   shape = createSquare();

          shape.position.copy(pos);
          shapeGroup.add(shape);
        }
      }
      scene.add(shapeGroup);
    }

    function createCircle() {
      const geometry = new THREE.CircleGeometry(0.2, 32);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }
    function createTriangle() {
      const geometry = new THREE.ConeGeometry(0.3, 0.3, 3);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }
    function createSquare() {
      const geometry = new THREE.PlaneGeometry(0.5, 0.2);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }

    // TEXT
    const addTextButton = document.getElementById('addTextButton');
    const textSizeInput = document.getElementById('textSize');

    addTextButton.addEventListener('click', function() {
      const text = document.getElementById('textInput').value;
      const textSize = parseInt(textSizeInput.value,10);
      if (text) {
        const c = document.createElement('div');
        c.className = 'textContainer';
        c.style.left = '100px';
        c.style.top  = '100px';

        const el = document.createElement('div');
        el.className = 'textElement';
        el.style.fontSize = `${textSize}px`;
        el.textContent = text;
        c.appendChild(el);

        document.body.appendChild(c);
        enableDrag(c);
        selectElement(c);
        pushHistory();
      }
    });

    function selectElement(element) {
      if (selectedElement) selectedElement.classList.remove('selected');
      selectedElement = element;
      selectedElement.classList.add('selected');

      if (selectedElement.classList.contains('textContainer')) {
        const px = parseInt(getComputedStyle(selectedElement.querySelector('.textElement')).fontSize,10);
        document.getElementById('textSize').value = px;
      } else if (selectedElement.classList.contains('icon')) {
        document.getElementById('iconSize').value = parseInt(selectedElement.style.width,10);
      }
    }

    function clearSelection() {
      if (selectedElement) {
        selectedElement.classList.remove('selected');
        selectedElement = null;
        rotationAngle = 0;
      }
    }

    document.addEventListener('pointerdown', (e) => {
      const onDraggable = e.target.closest('.textContainer, .icon');
      const onControls  = e.target.closest('#controls, #iconUploader, #textControls, #labelControls, #actionBar');
      if (!onDraggable && !onControls) clearSelection();
    });

    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') clearSelection(); });

    document.getElementById('rotateTextButton').addEventListener('click', function() {
      if (selectedElement) {
        rotationAngle = (rotationAngle + 5) % 360;
        selectedElement.style.transform = `rotate(${rotationAngle}deg)`;
        pushHistory();
      }
    });

    document.getElementById('textSize').addEventListener('change', function(e) {
      if (selectedElement && selectedElement.classList.contains('textContainer')) {
        selectedElement.querySelector('.textElement').style.fontSize = `${e.target.value}px`;
        pushHistory();
      }
    });

    // ICONS
    const iconUploader = document.getElementById('uploadIcon');
    const iconSizeInput = document.getElementById('iconSize');
    iconUploader.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const c = document.createElement('div');
          c.className = 'icon';
          c.style.width  = `${iconSizeInput.value}px`;
          c.style.height = `${iconSizeInput.value}px`;
          c.style.left   = '120px';
          c.style.top    = '120px';

          const img = document.createElement('img');
          img.src = e.target.result;
          c.appendChild(img);

          document.body.appendChild(c);
          enableDrag(c);
          selectElement(c);
          pushHistory();
        };
        reader.readAsDataURL(file);
      }
    });

    document.getElementById('rotateIconButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        rotationAngle = (rotationAngle + 5) % 360;
        selectedElement.style.transform = `rotate(${rotationAngle}deg)`;
        pushHistory();
      }
    });

    iconSizeInput.addEventListener('change', function(e) {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        selectedElement.style.width  = `${e.target.value}px`;
        selectedElement.style.height = `${e.target.value}px`;
        pushHistory();
      }
    });

    function enableDrag(element) {
      let isDown = false;
      let offsetX = 0, offsetY = 0;
      let activePointerId = null;

      function onPointerMove(e) {
        if (!isDown || e.pointerId !== activePointerId) return;
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        element.style.left = x + 'px';
        element.style.top  = y + 'px';
      }

      function onPointerUp(e) {
        if (e.pointerId !== activePointerId) return;
        isDown = false;
        activePointerId = null;
        element.classList.remove('dragging');

        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
        document.removeEventListener('pointercancel', onPointerUp);
        document.removeEventListener('pointerleave', onPointerUp);
        try { element.releasePointerCapture(e.pointerId); } catch(_) {}

        pushHistory();
      }

      element.addEventListener('pointerdown', (e) => {
        selectElement(element);
        const rect = element.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        isDown = true;
        activePointerId = e.pointerId;
        element.classList.add('dragging');

        try { element.setPointerCapture(e.pointerId); } catch(_) {}

        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
        document.addEventListener('pointercancel', onPointerUp);
        document.addEventListener('pointerleave', onPointerUp);

        e.preventDefault();
      });

      element.addEventListener('dragstart', (e) => e.preventDefault());
    }

    document.getElementById('deleteTextButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('textContainer')) {
        selectedElement.remove(); selectedElement = null;
        pushHistory();
      }
    });
    document.getElementById('deleteIconButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        selectedElement.remove(); selectedElement = null;
        pushHistory();
      }
    });

    // CLEAR
    const clearButton = document.getElementById('clearButton');
    clearButton.addEventListener('click', function() {
      document.querySelectorAll('.icon').forEach(icon => icon.remove());
      document.querySelectorAll('.textContainer').forEach(text => text.remove());

      shapeGroup.clear();
      lineGroup.clear();
      dimensionGroup.clear();
      runDirectionGroup?.clear();
      clearHtmlLabels();
      linesModel.length = 0;

      scene.clear();
      createWireframeBox();
      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);

      document.getElementById('runDirection').value = 'none';
      runDirectionRotationDeg = 0;
      runDirectionSprites = [];
      runDirectionCenter3D = null;

      viewOffsetX = 0;
      viewOffsetY = 0;

      updateDimensions();
      updateRunDirectionArrow();
      clearSelection();
      frameCamera();
      pushHistory();
    });

    function setupHistoryButtons() {
      document.getElementById('undoButton').addEventListener('click', undo);
      document.getElementById('redoButton').addEventListener('click', redo);
    }

    function setupSaveLoadButtons() {
      const saveBtn   = document.getElementById('saveStateButton');
      const loadBtn   = document.getElementById('loadStateButton');
      const loadInput = document.getElementById('loadStateInput');
      const specBtn   = document.getElementById('exportSpecJsonButton');

      // SAVE DRAWING: save to DB + download JSON
      saveBtn.addEventListener('click', async () => {
        const pn = (partNumberInput.value || '').trim();
        if (!pn) {
          alert('Enter Part Number first.');
          partNumberInput.focus();
          return;
        }

        const stateJSON = serializeState();

        // 1) Save to local DB (table)
        await dbUpsert(pn, stateJSON);
        await renderDbTable(dbSearchInput.value);

        // 2) Also download JSON file
        const blob = new Blob([stateJSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = pn.replace(/[^a-z0-9_\-]+/gi, '_') + '.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      loadBtn.addEventListener('click', () => {
        loadInput.value = '';
        loadInput.click();
      });

      loadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target.result;
          restoreState(text);
          pushHistory();
        };
        reader.readAsText(file);
      });

      specBtn.addEventListener('click', () => {
        const specJSON = buildSpecJson();
        const blob = new Blob([specJSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'panel_spec.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    function buildSpecJson() {
      return JSON.stringify({
        version: 1,
        panel: {
          width:      parseInches(widthInput.value),
          length:     parseInches(lengthInput.value),
          thickness:  parseInches(thicknessInput.value),
          partNumber: partNumberInput.value || ''
        },
        runDirection: document.getElementById('runDirection').value,
        runDirectionRotationDeg,
        notes: notesInput.value || '',
        lines: linesModel.map(l => ({
          kind:       l.kind,
          distance:   l.distance,
          lineLength: l.lineLength,
          styleKey:   l.lineType,
          label:      STYLE_LABELS[l.lineType] || l.lineType
        }))
      }, null, 2);
    }

    function serializeState() {
      return JSON.stringify({
        dims: {
          width:      parseInches(widthInput.value),
          length:     parseInches(lengthInput.value),
          thickness:  parseInches(thicknessInput.value),
          partNumber: partNumberInput.value || ''
        },
        lines: linesModel.slice(),
        runDirection: document.getElementById('runDirection').value,
        runDirectionRotationDeg,
        notes: notesInput.value || '',
        texts: Array.from(document.querySelectorAll('.textContainer')).map(c => {
          const el = c.querySelector('.textElement');
          return {
            text: el.textContent,
            fontSize: parseInt(getComputedStyle(el).fontSize,10),
            left: c.style.left || '0px',
            top: c.style.top || '0px',
            rotation: getRotationDeg(c.style.transform || '')
          };
        }),
        icons: Array.from(document.querySelectorAll('.icon')).map(c => {
          const img = c.querySelector('img');
          return {
            src: img.src,
            width: parseInt(c.style.width,10) || 100,
            height: parseInt(c.style.height,10) || 100,
            left: c.style.left || '0px',
            top: c.style.top || '0px',
            rotation: getRotationDeg(c.style.transform || '')
          };
        })
      });
    }

    function getRotationDeg(transformStr) {
      const m = /rotate\(([-\d.]+)deg\)/.exec(transformStr);
      return m ? parseFloat(m[1]) : 0;
    }

    function pushHistory() {
      redoStack.length = 0;
      history.push(serializeState());
      if (history.length > 50) history.shift();
    }

    function undo() {
      if (history.length < 2) return;
      const current = history.pop();
      redoStack.push(current);
      const prev = history[history.length - 1];
      restoreState(prev);
    }

    function redo() {
      if (redoStack.length === 0) return;
      const state = redoStack.pop();
      history.push(state);
      restoreState(state);
    }

    function restoreState(stateJSON) {
      const state = JSON.parse(stateJSON);

      widthInput.value     = formatInchesWithQuote(state.dims.width);
      lengthInput.value    = formatInchesWithQuote(state.dims.length);
      thicknessInput.value = formatInchesWithQuote(state.dims.thickness);
      partNumberInput.value = (state.dims.partNumber !== undefined) ? state.dims.partNumber : '';
      notesInput.value     = state.notes || '';

      const runDirSelect = document.getElementById('runDirection');
      runDirSelect.value = state.runDirection || 'none';

      if (typeof state.runDirectionRotationDeg === 'number') {
        runDirectionRotationDeg = state.runDirectionRotationDeg;
      } else {
        switch (runDirSelect.value) {
          case 'xPlus':  runDirectionRotationDeg = 0;   break;
          case 'xMinus': runDirectionRotationDeg = 180; break;
          case 'yPlus':  runDirectionRotationDeg = 90;  break;
          case 'yMinus': runDirectionRotationDeg = -90; break;
          default:       runDirectionRotationDeg = 0;
        }
      }

      viewOffsetX = 0;
      viewOffsetY = -6;

      linesModel.length = 0;
      (state.lines || []).forEach(l => linesModel.push(l));

      updateBox();

      document.querySelectorAll('.icon').forEach(n => n.remove());
      document.querySelectorAll('.textContainer').forEach(n => n.remove());

      (state.texts || []).forEach(t => {
        const c = document.createElement('div');
        c.className = 'textContainer';
        c.style.left = t.left;
        c.style.top  = t.top;
        c.style.transform = `rotate(${t.rotation}deg)`;

        const el = document.createElement('div');
        el.className = 'textElement';
        el.textContent = t.text;
        el.style.fontSize = `${t.fontSize}px`;
        c.appendChild(el);

        document.body.appendChild(c);
        enableDrag(c);
      });

      (state.icons || []).forEach(i => {
        const c = document.createElement('div');
        c.className = 'icon';
        c.style.left   = i.left;
        c.style.top    = i.top;
        c.style.width  = `${i.width}px`;
        c.style.height = `${i.height}px`;
        c.style.transform = `rotate(${i.rotation}deg)`;

        const img = document.createElement('img');
        img.src = i.src;
        c.appendChild(img);

        document.body.appendChild(c);
        enableDrag(c);
      });

      clearSelection();
      renderer.render(scene, camera);
      updateAllHtmlLabels();
    }

    function getRunDirectionScreenCenter() {
      if (!runDirectionCenter3D) return null;
      const rect = drawingArea.getBoundingClientRect();
      const pos = runDirectionCenter3D.clone();
      pos.project(camera);
      const x = (pos.x + 1) / 2 * rect.width;
      const y = (-pos.y + 1) / 2 * rect.height;
      return { x, y };
    }

    function onRunDirPointerDown(e) {
      const mode = document.getElementById('runDirection').value;
      if (mode === 'none') return;
      if (!runDirectionSprites || runDirectionSprites.length === 0) return;

      const rect = drawingArea.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      let minDist = Infinity;
      runDirectionSprites.forEach(sprite => {
        const pos = sprite.position.clone().project(camera);
        const sx = (pos.x + 1) / 2 * rect.width;
        const sy = (-pos.y + 1) / 2 * rect.height;
        const dx = px - sx;
        const dy = py - sy;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < minDist) minDist = d;
      });

      if (minDist > 40) return;

      const center = getRunDirectionScreenCenter();
      if (!center) return;

      const dx0 = px - center.x;
      const dy0 = py - center.y;
      dragStartAngleScreen = Math.atan2(dy0, dx0);
      dragStartRotationDeg = runDirectionRotationDeg || 0;
      isRotatingRunDir = true;
      e.preventDefault();
    }

    function onRunDirPointerMove(e) {
      if (!isRotatingRunDir) return;
      const rect = drawingArea.getBoundingClientRect();
      const center = getRunDirectionScreenCenter();
      if (!center) return;

      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const dx = px - center.x;
      const dy = py - center.y;

      const angle = Math.atan2(dy, dx);
      let deltaRad = angle - dragStartAngleScreen;

      if (deltaRad > Math.PI)  deltaRad -= 2 * Math.PI;
      if (deltaRad < -Math.PI) deltaRad += 2 * Math.PI;

      let deltaDeg = THREE.MathUtils.radToDeg(deltaRad);
      let total = dragStartRotationDeg + deltaDeg;

      const snapped = Math.round(total / 15) * 15;
      runDirectionRotationDeg = snapped;

      updateRunDirectionArrow();
    }

    function onRunDirPointerUp() {
      if (!isRotatingRunDir) return;
      isRotatingRunDir = false;
      pushHistory();
    }

    // EXPORT JPEG
    const exportButton = document.getElementById('exportButton');
    exportButton.addEventListener('click', function() {
      renderer.render(scene, camera);

      const finalCanvas  = document.createElement('canvas');
      const finalContext = finalCanvas.getContext('2d');

      finalCanvas.width  = DRAW_WIDTH;
      finalCanvas.height = DRAW_HEIGHT;

      finalContext.drawImage(renderer.domElement, 0, 0);

      const areaRect = drawingArea.getBoundingClientRect();

      const icons = document.querySelectorAll('.icon img');
      icons.forEach(icon => {
        const r = icon.getBoundingClientRect();
        const x = r.left - areaRect.left;
        const y = r.top  - areaRect.top;
        finalContext.drawImage(icon, x, y, r.width, r.height);
      });

      const texts = document.querySelectorAll('.textElement');
      texts.forEach(text => {
        const r = text.getBoundingClientRect();
        const x = r.left - areaRect.left;
        const y = r.top  - areaRect.top;
        const sizePx = parseInt(getComputedStyle(text).fontSize,10);
        const lineHeight = Math.round(sizePx * 1.2);
        finalContext.font = `${sizePx}px Arial`;
        finalContext.fillStyle = '#000';

        const lines = (text.textContent || '').split(/\r?\n/);
        let yy = y + sizePx;
        lines.forEach((ln) => {
          finalContext.fillText(ln, x, yy);
          yy += lineHeight;
        });
      });

      htmlLabels.forEach(lbl => {
        const mid = lbl.pos3.clone();
        mid.project(camera);
        const x = (mid.x + 1) / 2 * finalCanvas.width;
        const y = (-mid.y + 1) / 2 * finalCanvas.height;

        const s = lbl.start3.clone().project(camera);
        const e = lbl.end3.clone().project(camera);
        const sx = (s.x + 1) / 2 * finalCanvas.width;
        const sy = (-s.y + 1) / 2 * finalCanvas.height;
        const ex = (e.x + 1) / 2 * finalCanvas.width;
        const ey = (-e.y + 1) / 2 * finalCanvas.height;

        let angleRad = Math.atan2(ey - sy, ex - sx);
        if (lbl.flipLabel) angleRad += Math.PI;

        if (angleRad > Math.PI)  angleRad -= 2 * Math.PI;
        if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
        if (angleRad >  Math.PI / 2)  angleRad -= Math.PI;
        if (angleRad < -Math.PI / 2)  angleRad += Math.PI;

        const coreText = lbl.text || '';
        const padded = '  ' + coreText + '  ';

        const fontSize = 14;
        finalContext.font = `${fontSize}px Arial`;
        const metrics = finalContext.measureText(padded);
        const textWidth  = metrics.width;
        const textHeight = fontSize * 1.4;

        if (labelHasBackground(lbl.styleKey)) {
          finalContext.save();
          finalContext.translate(x, y);
          finalContext.rotate(angleRad);
          finalContext.fillStyle = '#ffffff';
          finalContext.fillRect(-textWidth / 2 - 4, -textHeight / 2 + 2, textWidth + 8, textHeight);
          finalContext.restore();
        }

        finalContext.save();
        finalContext.translate(x, y);
        finalContext.rotate(angleRad);
        finalContext.fillStyle = '#000000';
        finalContext.textAlign = 'center';
        finalContext.textBaseline = 'middle';
        finalContext.fillText(padded, 0, 0);
        finalContext.restore();
      });

      const link = document.createElement('a');
      const rawPart = (partNumberInput.value || '').trim();
      const safeName = rawPart ? rawPart.replace(/[^a-z0-9_\-]+/gi, '_') : 'scene_export';
      link.href = finalCanvas.toDataURL('image/jpeg');
      link.download = safeName + '.jpeg';
      link.click();
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      updateAllHtmlLabels();
    }

    init();
  </script>
</body>
</html>
