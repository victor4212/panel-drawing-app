<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Panel Drawing</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background-color: white;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      overflow: hidden;
    }

    /* Fixed drawing area */
    #drawingArea {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1200px;
      height: 850px;
      border: 1px solid #000;
      background: #fff;
      overflow: hidden;
    }

    #drawingArea canvas {
      display: block;
    }

    /* 4 small arrows to help center the drawing (clickable) */
    .centerArrow {
      position: absolute;
      font-size: 18px;
      color: #000;
      opacity: 0.5;
      cursor: pointer;
      pointer-events: auto;
    }
    .arrowTop    { top: 4px;    left: 50%; transform: translateX(-50%); }
    .arrowBottom { bottom: 4px; left: 50%; transform: translateX(-50%) rotate(180deg); }
    .arrowLeft   { left: 4px;   top: 50%;  transform: translateY(-50%) rotate(-90deg); }
    .arrowRight  { right: 4px;  top: 50%;  transform: translateY(-50%) rotate(90deg); }

    /* HTML overlay for line labels */
    #labelsOverlay {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 15;
    }
    .lineLabel {
      position: absolute;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size: 14px;
      color: #000;
      white-space: nowrap;
      pointer-events: auto;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(255,255,255,.9);
      padding: 6px 8px;
      border-radius: 8px;
      box-shadow: 0 1px 6px rgba(0,0,0,.06);
    }
    #zoomSliderContainer {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      z-index: 20;
    }
    #zoomSlider { width: 50%; }

    #iconUploader, #textControls, #labelControls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 20;
      background: rgba(255,255,255,.9);
      padding: 6px 8px;
      border-radius: 8px;
      box-shadow: 0 1px 6px rgba(0,0,0,.06);
    }
    #textControls { top: 140px; }
    #labelControls { top: 270px; }

    /* Action bar: 2 buttons per row */
    #actionBar {
      position: fixed;
      right: 10px;
      top: 360px;
      z-index: 21;
      display: grid;
      grid-template-columns: repeat(2, max-content);
      grid-auto-rows: auto;
      gap: 6px 10px;
      align-items: center;
      background: rgba(255,255,255,.9);
      padding: 6px 8px;
      border-radius: 10px;
      box-shadow: 0 1px 6px rgba(0,0,0,.08);
    }
    #actionBar button { white-space: nowrap; }

    #textControls button,
    #iconUploader button,
    #labelControls button { margin-right: 5px; }

    .icon {
      position: absolute;
      width: 100px; height: 100px;
      z-index: 22;
      border: 0px dashed #000;
      transform-origin: center center;
    }
    .icon img { width: 100%; height: 100%; object-fit: contain; }

    .textContainer {
      position: absolute;
      padding: 5px;
      z-index: 22;
      border: 0px dashed #000;
      transform-origin: center center;
      background: transparent;
    }
    .textElement {
      font-size: 20px;
      white-space: pre-wrap;
      line-height: 1.2;
    }

    /* CHANGED: these are now text inputs to allow fractions */
    #partNumber,
    #width, #length, #thickness,
    #lineLengthY, #distanceFromX,
    #lineLengthX, #distanceFromY,
    #iconSize, #textSize { width: 100px; }

    #lineType { width: 180px; }

    .selected { outline: 3px solid #216cff; border-radius: 6px; }

    .textContainer, .icon {
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
      cursor: grab;
    }
    .dragging { cursor: grabbing; }
  </style>
</head>
<body>
  <!-- Fixed drawing area (1200 x 850) -->
  <div id="drawingArea">
    <div id="labelsOverlay"></div>
    <!-- 4 small arrows to visually move the drawing -->
    <div class="centerArrow arrowTop">▲</div>
    <div class="centerArrow arrowBottom">▲</div>
    <div class="centerArrow arrowLeft">▲</div>
    <div class="centerArrow arrowRight">▲</div>
  </div>

  <div id="controls">
    <!-- NEW: Part number field -->
    <label>Part Number: <input type="text" id="partNumber" placeholder="e.g. P-12345"></label><br>

    <!-- CHANGED: type="text" so you can type 48 1/2, etc -->
    <label>Length: <input type="text" id="width" value="48"></label><br>
    <label>Width: <input type="text" id="length" value="36"></label><br>
    <label>Thickness: <input type="text" id="thickness" value="1"></label><br>

    <!-- Panel presets -->
    <label>Panel Preset:
      <select id="panelPreset">
        <option value="custom">Custom (manual)</option>
        <option value="48x48x1">48 × 48 × 1</option>
        <option value="48x96x1">48 × 96 × 1</option>
        <option value="96x48x1">96 × 48 × 1</option>
        <option value="96x96x2">96 × 96 × 2</option>
      </select>
    </label><br>

    <!-- Run direction arrow -->
    <label>Run Direction:
      <select id="runDirection">
        <option value="none">None</option>
        <option value="xPlus">Along length →</option>
        <option value="xMinus">Along length ←</option>
        <option value="yPlus">Along width ↑</option>
        <option value="yMinus">Along width ↓</option>
      </select>
    </label><br>

    <!-- Separate layout presets -->
    <label>Width Lines:
      <select id="layoutPresetWidth">
        <option value="none">— Width layout —</option>
        <option value="bands2">2 bands (width)</option>
        <option value="bands3">3 bands (width)</option>
        <option value="bands4">4 bands (width)</option>
        <option value="bands5">5 bands (width)</option>
        <option value="bands6">6 bands (width)</option>
        <option value="bands7">7 bands (width)</option>
        <option value="bands8">8 bands (width)</option>
        <option value="bands9">9 bands (width)</option>
        <option value="bands10">10 bands (width)</option>
        <option value="bands12">12 bands (width)</option>
        <option value="bands15">15 bands (width)</option>
        <option value="bands24">24 bands (width)</option>
      </select>
    </label><br>

    <label>Length Lines:
      <select id="layoutPresetLength">
        <option value="none">— Length layout —</option>
        <option value="bands2">2 bands (length)</option>
        <option value="bands3">3 bands (length)</option>
        <option value="bands4">4 bands (length)</option>
        <option value="bands5">5 bands (length)</option>
        <option value="bands6">6 bands (length)</option>
        <option value="bands7">7 bands (length)</option>
        <option value="bands8">8 bands (length)</option>
        <option value="bands9">9 bands (length)</option>
        <option value="bands10">10 bands (length)</option>
        <option value="bands12">12 bands (length)</option>
        <option value="bands15">15 bands (length)</option>
        <option value="bands24">24 bands (length)</option>
      </select>
    </label><br><br>

    <label>Cut Style:
      <select id="lineType">
        <optgroup label="— Line Styles —">
          <option value="solid">Slit</option>
          <option value="dot">Dot</option>
          <option value="shortDash">Short Dash</option>
          <option value="longDash">Long Dash</option>
          <option value="shortDashDot">Short Dash + Dot</option>
          <option value="longDashDot">Long Dash + Dot</option>
          <option value="shortDash2Dot">Short Dash + 2 Dots</option>
          <option value="longDash2Dot">Long Dash + 2 Dots</option>
        </optgroup>
        <optgroup label="— Shapes on Line —">
          <option value="circle1">Line with 1 Circle</option>
          <option value="circle2">Line with 2 Circles</option>
          <option value="circle3">Line with 3 Circles</option>
          <option value="circle4">Line with 4 Circles</option>
          <option value="triangle1">Line with 1 Triangle</option>
          <option value="triangle2">Line with 2 Triangles</option>
          <option value="triangle3">Line with 3 Triangles</option>
          <option value="triangle4">Line with 4 Triangles</option>
          <option value="square1">Line with 1 Square</option>
          <option value="square2">Line with 2 Squares</option>
          <option value="square3">Line with 3 Squares</option>
          <option value="square4">Line with 4 Squares</option>
        </optgroup>
        <optgroup label="— Symbol Styles —">
          <option value="waterTrigram">☵ Water Trigram</option>
          <option value="mountainTrigram">☶ Mountain Trigram</option>
          <option value="earthTrigram">☷ Earth Trigram</option>
          <option value="yangMonogram">⚍ Yang Monogram</option>
          <option value="yinMonogram">⚏ Yin Monogram</option>
          <option value="recycleSymbol">♻ Recycling Symbol</option>
          <option value="arrowhead">➤ Arrowhead</option>
          <option value="concaveArrow">➨ Concave Arrow</option>
          <option value="doubleAngle">» Double Angle</option>
          <option value="doubleBar">‖ Double Bar</option>

          <!-- NEW symbol styles you requested -->
          <option value="diamondArrow">◇─◆─ Pattern</option>
          <option value="crossCross">◈━◈━ Pattern</option>
          <option value="crossDiamond">◈━◆━ Pattern</option>
          <option value="diamondLine">◇─ Line</option>
          <option value="squareLine">◆─ Line</option>
          <option value="heavyDoubleLine">═══ Heavy Line</option>
          <option value="arrowRightLine">──▶ Right Arrow Line</option>
          <option value="arrowLeftLine">◀── Left Arrow Line</option>
        </optgroup>
      </select>
    </label><br>

    <!-- CHANGED: line inputs are text to allow fractions -->
    <label>Line Width: <input type="text" id="lineLengthY" value="48"></label><br>
    <label>Distance From Width: <input type="text" id="distanceFromX" value="4"></label><br>
    <button onclick="addYtoYLine()">Add Width Line</button><br>

    <label>Line Length: <input type="text" id="lineLengthX" value="36"></label><br>
    <label>Distance From length: <input type="text" id="distanceFromY" value="4"></label><br>
    <button onclick="addXtoXLine()">Add Length Line</button>
    <br><br><br>
    <textarea id="notes" placeholder="Enter notes here..."></textarea>

<div id="recordsPanel" style="margin-top:10px; width:260px;">
  <div style="display:flex; gap:6px; align-items:center;">
    <input id="dbSearchInput" placeholder="Search part..." style="flex:1; padding:6px; border:1px solid #ccc; border-radius:6px;">
    <button id="refreshDbBtn" title="Refresh" style="padding:6px 10px;">↻</button>
  </div>

  <div id="recordsList" style="margin-top:8px; max-height:220px; overflow:auto; border:1px solid #ddd; border-radius:8px; padding:6px;"></div>

  <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap;">
    <button id="dbSaveBtn" style="padding:6px 10px;">Save to DB</button>
    <button id="dbLoadBtn" style="padding:6px 10px;">Load from DB</button>
  </div>
</div>
  </div>

  <div id="zoomSliderContainer">
    <input type="range" id="zoomSlider" min="0" max="100" value="40">
  </div>

  <div id="iconUploader">
    <input type="file" id="uploadIcon" accept="image/*"><br>
    <button id="rotateIconButton">Rotate Icon</button>
    <button id="deleteIconButton">Delete Icon</button><br>
    <label for="iconSize">Icon Size: </label>
    <input type="number" id="iconSize" value="50" step="10"> px<br>
  </div>

  <div id="textControls">
    <label for="textInput">Text:</label><br>
    <textarea id="textInput" rows="4" cols="26" placeholder="Enter multi-line text..."></textarea><br>
    <label for="textSize">Text Size: </label>
    <input type="number" id="textSize" value="12" step="1"><br>
    <button id="addTextButton">Add Text</button><br>
    <button id="rotateTextButton">Rotate Text</button>
    <button id="deleteTextButton">Delete Text</button>
  </div>

  <!-- Hidden file input for loading state -->
  <input type="file" id="loadStateInput" accept=".json,.txt" style="display:none">

  <!-- Fixed action bar -->
  <div id="actionBar" role="toolbar" aria-label="Drawing actions">
    <button id="undoButton">Undo</button>
    <button id="redoButton">Redo</button>
    <button id="clearButton">Clear All</button>
    <button id="exportButton">Export as JPEG</button>
    <button id="saveStateButton">Save Drawing</button>
    <button id="loadStateButton">Load Drawing</button>
    <button id="exportSpecJsonButton">Export Spec JSON</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    const DRAW_WIDTH  = 1200;
    const DRAW_HEIGHT = 850;

    // NEW: camera view offset so arrows can move the drawing
    let viewOffsetX = 0;
    let viewOffsetY = -6; // your previous -6 that you liked
    const VIEW_STEP  = 0.5; // how much to move per click

    let scene, camera, renderer, wireframeBox, lineGroup, shapeGroup, dimensionGroup, runDirectionGroup;
    const drawingArea      = document.getElementById('drawingArea');
    const labelsOverlayDom = document.getElementById('labelsOverlay');

    const partNumberInput   = document.getElementById('partNumber');
    const widthInput        = document.getElementById('width');
    const lengthInput       = document.getElementById('length');
    const thicknessInput    = document.getElementById('thickness');
    const lineLengthYInput  = document.getElementById('lineLengthY');
    const distanceFromXInput= document.getElementById('distanceFromX');
    const lineLengthXInput  = document.getElementById('lineLengthX');
    const distanceFromYInput= document.getElementById('distanceFromY');
    const zoomSlider        = document.getElementById('zoomSlider');
    const notesInput        = document.getElementById('notes');

    let selectedElement = null;
    let rotationAngle = 0;

    const history   = [];
    const redoStack = [];
    const linesModel = []; // { kind: 'Y'|'X', lineLength, distance, lineType }

    const htmlLabels = []; // { text,pos3,start3,end3,flipLabel,el,styleKey }

    const LINE_COLOR = 0x000000;
    const LINE_STYLES = {
      solid:         { mode: 'solid' },
      shortDash:     { mode: 'dash',    dash: 1.0,  gap: 0.6 },
      longDash:      { mode: 'dash',    dash: 2.4,  gap: 0.8 },
      dot:           { mode: 'dot',     dotRadius: 0.15, dotSpacing: 0.8 },
      shortDashDot:  { mode: 'dashdot', dash: 1.0,  gap: 0.8, dotRadius: 0.15 },
      longDashDot:   { mode: 'dashdot', dash: 3,    gap: 1,   dotRadius: 0.15 },
      shortDash2Dot: { mode: 'dash2dot',dash: 1.0,  gap: 1.7, dotRadius: 0.15 },
      longDash2Dot:  { mode: 'dash2dot',dash: 3,    gap: 2,   dotRadius: 0.15 },
    };

    const STYLE_LABELS = {
      solid:        'Slit',
      dot:          'Dot',
      shortDash:    'Short Dash',
      longDash:     'Long Dash',
      shortDashDot: 'Short Dash + Dot',
      longDashDot:  'Long Dash + Dot',
      shortDash2Dot:'Short Dash + 2 Dots',
      longDash2Dot: 'Long Dash + 2 Dots',

      circle1:   'Circle 1',
      circle2:   'Circle 2',
      circle3:   'Circle 3',
      circle4:   'Circle 4',
      triangle1: 'Triangle 1',
      triangle2: 'Triangle 2',
      triangle3: 'Triangle 3',
      triangle4: 'Triangle 4',
      square1:   'Square 1',
      square2:   'Square 2',
      square3:   'Square 3',
      square4:   'Square 4',

      waterTrigram:    '☵ Water Trigram',
      mountainTrigram: '☶ Mountain Trigram',
      earthTrigram:    '☷ Earth Trigram',
      yangMonogram:    '⚍ Yang Monogram',
      yinMonogram:     '⚏ Yin Monogram',
      recycleSymbol:   '♻ Recycling Symbol',
      arrowhead:       '➤ Arrowhead',
      concaveArrow:    '➨ Concave Arrow',
      doubleAngle:     '» Double Angle',
      doubleBar:       '‖ Double Bar',

      /* NEW: label names for your new patterns */
      diamondArrow:     '◇─◆─ Pattern',
      crossCross:       '◈━◈━ Pattern',
      crossDiamond:     '◈━◆━ Pattern',
      diamondLine:      '◇─ Line',
      squareLine:       '◆─ Line',
      heavyDoubleLine:  '═══ Heavy Line',
      arrowRightLine:   '──▶ Right Arrow Line',
      arrowLeftLine:    '◀── Left Arrow Line'
    };

    const PANEL_PRESETS = {
      '48x48x1': { width: 48, length: 48, thickness: 1 },
      '48x96x1': { width: 48, length: 96, thickness: 1 },
      '96x48x1': { width: 96, length: 48, thickness: 1 },
      '96x96x2': { width: 96, length: 96, thickness: 2 }
    };

    const SYMBOL_STYLES = {
      waterTrigram:    '☵',
      mountainTrigram: '☶',
      earthTrigram:    '☷',
      yangMonogram:    '⚍',
      yinMonogram:     '⚏',
      recycleSymbol:   '♻',
      arrowhead:       '➤',
      concaveArrow:    '➨',
      doubleAngle:     '»',
      doubleBar:       '‖',

      /* NEW: multi-character patterns */
      diamondArrow:    '◇─◆─',
      crossCross:      '◈━◈━',
      crossDiamond:    '◈━◆━',
      diamondLine:     '◇─',
      squareLine:      '◆─',
      heavyDoubleLine: '═══',
      arrowRightLine:  '──▶',
      arrowLeftLine:   '◀──'
    };

    const symbolTextures = {};

    // Run-direction arrow rotation state
    let runDirectionRotationDeg = 0;
    let runDirectionSprite = null;
    let runDirectionSprites = [];
    let runDirectionCenter3D = null;
    let isRotatingRunDir = false;
    let dragStartAngleScreen = 0;
    let dragStartRotationDeg = 0;

    /* --------- FRACTION HELPERS (inches) ---------- */
    function gcd(a, b) {
      a = Math.abs(a);
      b = Math.abs(b);
      if (a < 1e-8) return b || 1;
      if (b < 1e-8) return a || 1;
      while (b > 1e-8) {
        const t = b;
        b = a % b;
        a = t;
      }
      return a || 1;
    }

    function parseInches(str) {
      if (str == null) return NaN;
      str = String(str).trim();
      if (!str) return NaN;

      // remove inch symbol
      str = str.replace(/"/g, '').trim();

      let sign = 1;
      if (str[0] === '+') {
        str = str.slice(1).trim();
      } else if (str[0] === '-') {
        sign = -1;
        str = str.slice(1).trim();
      }
      if (!str) return NaN;

      const parts = str.split(/\s+/);

      let whole = 0;
      let frac = 0;

      if (parts.length === 1) {
        const p = parts[0];
        if (p.includes('/')) {
          const [n, d] = p.split('/');
          if (!d || isNaN(+d)) return NaN;
          frac = parseFloat(n) / parseFloat(d);
        } else {
          whole = parseFloat(p);
          if (isNaN(whole)) return NaN;
        }
      } else {
        const wPart = parts[0];
        whole = parseFloat(wPart);
        if (isNaN(whole)) return NaN;
        const fracPart = parts[1];
        if (fracPart.includes('/')) {
          const [n,d] = fracPart.split('/');
          if (!d || isNaN(+d)) return NaN;
          frac = parseFloat(n) / parseFloat(d);
        } else {
          const val2 = parseFloat(fracPart);
          if (!isNaN(val2)) frac = val2;
        }
      }

      return sign * (whole + frac);
    }

    function formatInches(val) {
      if (!isFinite(val)) return '';
      const sign = val < 0 ? '-' : '';
      let v = Math.abs(val);

      const epsilon = 1e-6;
      v = v + epsilon;

      let whole = Math.floor(v);
      let frac  = v - whole;

      const denomBase = 16;
      let num = Math.round(frac * denomBase);

      if (num === 0) {
        return sign + whole;
      }
      if (num === denomBase) {
        whole += 1;
        return sign + whole;
      }

      const g = gcd(num, denomBase);
      num /= g;
      const denom = denomBase / g;

      if (whole === 0) {
        return `${sign}${num}/${denom}`;
      }
      return `${sign}${whole} ${num}/${denom}`;
    }

    function formatInchesWithQuote(val) {
      const f = formatInches(val);
      return f ? f + '"' : '';
    }

    /* ---------------------------------------------- */

    function getSymbolTexture(symbolStr) {
      if (symbolTextures[symbolStr]) return symbolTextures[symbolStr];
      const canvas = document.createElement('canvas');
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0,0,256,128);
      ctx.fillStyle = '#000000';
      ctx.font = '64px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(symbolStr, 128, 64);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      symbolTextures[symbolStr] = tex;
      return tex;
    }

    function drawStyledLine(start, end, styleKey) {
      const cfg = LINE_STYLES[styleKey] || LINE_STYLES.solid;
      const group = new THREE.Group();
      const dir = new THREE.Vector3().subVectors(end, start);
      const length = dir.length();
      if (length <= 0.0001) return group;
      dir.normalize();

      const lineMat = new THREE.LineBasicMaterial({ color: LINE_COLOR });
      const dotMat  = new THREE.MeshBasicMaterial({ color: LINE_COLOR });

      function dotMesh(r) {
        const geo = new THREE.SphereGeometry(r, 12, 12);
        return new THREE.Mesh(geo, dotMat);
      }
      function addSegment(t0, t1) {
        const p0 = start.clone().add(dir.clone().multiplyScalar(t0));
        const p1 = start.clone().add(dir.clone().multiplyScalar(t1));
        const g = new THREE.BufferGeometry().setFromPoints([p0, p1]);
        const seg = new THREE.Line(g, lineMat);
        group.add(seg);
      }
      function addDotsInGap(tGapStart, tGapEnd, n, r) {
        if (n <= 0) return;
        const span = tGapEnd - tGapStart;
        if (span <= 0) return;
        if (n === 1) {
          const t = tGapStart + span * 0.5;
          const p = start.clone().add(dir.clone().multiplyScalar(t));
          const m = dotMesh(r); m.position.copy(p); group.add(m);
        } else {
          const step = span / (n + 1);
          for (let i = 1; i <= n; i++) {
            const t = tGapStart + step * i;
            const p = start.clone().add(dir.clone().multiplyScalar(t));
            const m = dotMesh(r); m.position.copy(p); group.add(m);
          }
        }
      }

      switch (cfg.mode) {
        case 'solid': {
          addSegment(0, length);
          break;
        }
        case 'dash': {
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const t0 = t;
            const t1 = Math.min(t + cfg.dash, length);
            if (t1 > t0) addSegment(t0, t1);
          }
          break;
        }
        case 'dot': {
          const spacing = cfg.dotSpacing;
          const r = cfg.dotRadius;
          for (let t = 0; t <= length; t += spacing) {
            const p = start.clone().add(dir.clone().multiplyScalar(Math.min(t, length)));
            const m = dotMesh(r); m.position.copy(p); group.add(m);
          }
          break;
        }
        case 'dashdot': {
          const r = cfg.dotRadius;
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const d0 = t;
            const d1 = Math.min(t + cfg.dash, length);
            if (d1 > d0) addSegment(d0, d1);
            const g0 = d1;
            const g1 = Math.min(d1 + cfg.gap, length);
            addDotsInGap(g0, g1, 1, r);
          }
          break;
        }
        case 'dash2dot': {
          const r = cfg.dotRadius;
          const cycle = cfg.dash + cfg.gap;
          for (let t = 0; t < length; t += cycle) {
            const d0 = t;
            const d1 = Math.min(t + cfg.dash, length);
            if (d1 > d0) addSegment(d0, d1);
            const g0 = d1;
            const g1 = Math.min(d1 + cfg.gap, length);
            addDotsInGap(g0, g1, 2, r);
          }
          break;
        }
      }
      return group;
    }

    function getLabelDisplayText(key) {
      return STYLE_LABELS[key] || key;
    }

    function applyStyleLabelOverridesToSelect() {
      const select = document.getElementById('lineType');
      Array.from(select.options).forEach(opt => {
        const key = opt.value;
        if (STYLE_LABELS[key]) opt.textContent = STYLE_LABELS[key];
      });
    }

    function isVertical(start, end) {
      return Math.abs(start.x - end.x) < 1e-6 && Math.abs(start.z - end.z) > 1e-6;
    }

    function labelHasBackground(styleKey) {
      return true;
    }

    function clearHtmlLabels() {
      htmlLabels.forEach(l => l.el.remove());
      htmlLabels.length = 0;
    }

    function addLabel(displayText, position, isVertical, styleKey, start, end, flipLabel) {
      const core   = (displayText || '').trim();
      const padded = '  ' + core + '  ';

      const label = document.createElement('div');
      label.className = 'lineLabel';
      label.textContent = padded;

      label.dataset.textCore   = core;
      label.dataset.styleKey   = styleKey || '';
      label.dataset.isVertical = isVertical ? '1' : '0';

      if (labelHasBackground(styleKey)) {
        label.style.background = '#ffffff';
        label.style.border = '1px solid #ffffff';
        label.style.padding = '2px 8px';
      }

      label.addEventListener('dblclick', () => {
        const current = label.dataset.textCore || '';
        const updated = prompt('Edit label text:', current);
        if (updated !== null && updated.trim() !== current) {
          const newCore = updated.trim();
          label.dataset.textCore = newCore;
          label.textContent = '  ' + newCore + '  ';
        }
      });

      labelsOverlayDom.appendChild(label);

      const record = {
        text: core,
        pos3: position.clone(),
        start3: start.clone(),
        end3: end.clone(),
        flipLabel: !!flipLabel,
        el: label,
        styleKey: styleKey || ''
      };
      htmlLabels.push(record);
      updateOneHtmlLabel(record);
    }

    function updateOneHtmlLabel(lbl) {
      const rect = drawingArea.getBoundingClientRect();

      const mid = lbl.pos3.clone();
      mid.project(camera);
      const x = (mid.x + 1) / 2 * rect.width;
      const y = (-mid.y + 1) / 2 * rect.height;

      const s = lbl.start3.clone().project(camera);
      const e = lbl.end3.clone().project(camera);
      const sx = (s.x + 1) / 2 * rect.width;
      const sy = (-s.y + 1) / 2 * rect.height;
      const ex = (e.x + 1) / 2 * rect.width;
      const ey = (-e.y + 1) / 2 * rect.height;

      let angleRad = Math.atan2(ey - sy, ex - sx);
      if (lbl.flipLabel) angleRad += Math.PI;

      if (angleRad > Math.PI)  angleRad -= 2 * Math.PI;
      if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
      if (angleRad >  Math.PI / 2)  angleRad -= Math.PI;
      if (angleRad < -Math.PI / 2)  angleRad += Math.PI;

      const angleDeg = angleRad * 180 / Math.PI;

      lbl.el.style.left = x + 'px';
      lbl.el.style.top  = y + 'px';
      lbl.el.style.transform = `translate(-50%, -50%) rotate(${angleDeg}deg)`;
    }

    function updateAllHtmlLabels() {
      htmlLabels.forEach(updateOneHtmlLabel);
    }

    function addSymbolLine(symbolKey, start, end, orientation) {
      const symbolStr = SYMBOL_STYLES[symbolKey];
      if (!symbolStr) return;

      const tex = getSymbolTexture(symbolStr);
      const dir = new THREE.Vector3().subVectors(end, start);
      const length = dir.length();
      if (length <= 0.0001) return;
      dir.normalize();

      const spacing = 1.0;
      const halfSpacing = spacing / 2;
      let rotationRad = 6; // your previous choice

      for (let t = halfSpacing; t < length; t += spacing) {
        const pos = start.clone().add(dir.clone().multiplyScalar(t));
        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
        const sprite = new THREE.Sprite(mat);
        sprite.position.copy(pos);
        const size = 2.0;
        sprite.scale.set(size, size, size);
        sprite.material.rotation = rotationRad;
        shapeGroup.add(sprite);
      }
    }

    function setupPanelLayoutPresets() {
      const panelSelect       = document.getElementById('panelPreset');
      const layoutWidthSelect = document.getElementById('layoutPresetWidth');
      const layoutLenSelect   = document.getElementById('layoutPresetLength');

      panelSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        const preset = PANEL_PRESETS[val];
        if (!preset) return;
        widthInput.value     = formatInchesWithQuote(preset.width);
        lengthInput.value    = formatInchesWithQuote(preset.length);
        thicknessInput.value = formatInchesWithQuote(preset.thickness);
        updateBox();
        pushHistory();
      });

      layoutWidthSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'none') return;

        const cubeWidth  = parseInches(widthInput.value);
        const cubeLength = parseInches(lengthInput.value);
        if (!cubeWidth || !cubeLength) {
          alert('Set panel dimensions first.');
          e.target.value = 'none';
          return;
        }
        const n = parseInt(val.replace('bands',''),10);
        if (!n || n < 2) { e.target.value = 'none'; return; }

        if (!confirm('Apply WIDTH layout preset and remove existing width lines?')) {
          e.target.value = 'none';
          return;
        }
        for (let i = linesModel.length - 1; i >= 0; i--) {
          if (linesModel[i].kind === 'Y') linesModel.splice(i,1);
        }
        const lineType = document.getElementById('lineType').value;
        const stepX = cubeWidth / n;
        for (let k=1;k<n;k++){
          const dist = k * stepX;
          linesModel.push({kind:'Y', lineLength:cubeLength, distance:dist, lineType});
        }
        rebuildLinesFromModel();
        e.target.value='none';
        pushHistory();
      });

      layoutLenSelect.addEventListener('change', (e) => {
        const val = e.target.value;
        if (val === 'none') return;

        const cubeWidth  = parseInches(widthInput.value);
        const cubeLength = parseInches(lengthInput.value);
        if (!cubeWidth || !cubeLength) {
          alert('Set panel dimensions first.');
          e.target.value = 'none';
          return;
        }
        const n = parseInt(val.replace('bands',''),10);
        if (!n || n < 2) { e.target.value = 'none'; return; }

        if (!confirm('Apply LENGTH layout preset and remove existing length lines?')) {
          e.target.value = 'none';
          return;
        }
        for (let i = linesModel.length - 1; i >= 0; i--) {
          if (linesModel[i].kind === 'X') linesModel.splice(i,1);
        }
        const lineType = document.getElementById('lineType').value;
        const stepZ = cubeLength / n;
        for (let k=1;k<n;k++){
          const dist = k * stepZ;
          linesModel.push({kind:'X', lineLength:cubeWidth, distance:dist, lineType});
        }
        rebuildLinesFromModel();
        e.target.value='none';
        pushHistory();
      });
    }

    // NEW: helper – always look at the current offset
    function applyCameraLook() {
      if (!camera) return;
      camera.lookAt(viewOffsetX, viewOffsetY, 0);
      camera.updateProjectionMatrix();
    }

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(
        30,
        DRAW_WIDTH / DRAW_HEIGHT,
        0.1,
        1000
      );

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(1);
      renderer.setSize(DRAW_WIDTH, DRAW_HEIGHT, false);
      drawingArea.appendChild(renderer.domElement);

      applyStyleLabelOverridesToSelect();
      createWireframeBox();
      lineGroup  = new THREE.Group();
      shapeGroup = new THREE.Group();
      dimensionGroup = new THREE.Group();
      runDirectionGroup = new THREE.Group();
      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);

      widthInput.addEventListener('input', updateBox);
      lengthInput.addEventListener('input', updateBox);
      thicknessInput.addEventListener('input', updateBox);
      zoomSlider.addEventListener('input', updateZoom);

      widthInput.addEventListener('change', pushHistory);
      lengthInput.addEventListener('change', pushHistory);
      thicknessInput.addEventListener('change', pushHistory);

      window.addEventListener('resize', onResize, false);
      setupHistoryButtons();
      setupSaveLoadButtons();
      setupPanelLayoutPresets();

      const runDirSelect = document.getElementById('runDirection');
      runDirSelect.addEventListener('change', () => {
        const val = runDirSelect.value;
        switch (val) {
          case 'xPlus':  runDirectionRotationDeg = 0;   break;
          case 'xMinus': runDirectionRotationDeg = 180; break;
          case 'yPlus':  runDirectionRotationDeg = 90;  break;
          case 'yMinus': runDirectionRotationDeg = -90; break;
          default:       runDirectionRotationDeg = 0;   break;
        }
        updateRunDirectionArrow();
        pushHistory();
      });

      // REPLACED: now each arrow pans the camera target
      const topArrow    = drawingArea.querySelector('.arrowTop');
      const bottomArrow = drawingArea.querySelector('.arrowBottom');
      const leftArrow   = drawingArea.querySelector('.arrowLeft');
      const rightArrow  = drawingArea.querySelector('.arrowRight');

      if (topArrow) {
        topArrow.addEventListener('click', () => {
          viewOffsetY -= VIEW_STEP;
          applyCameraLook();
          updateAllHtmlLabels();
        });
      }
      if (bottomArrow) {
        bottomArrow.addEventListener('click', () => {
          viewOffsetY += VIEW_STEP;
          applyCameraLook();
          updateAllHtmlLabels();
        });
      }
      if (leftArrow) {
        leftArrow.addEventListener('click', () => {
          viewOffsetX -= VIEW_STEP;
          applyCameraLook();
          updateAllHtmlLabels();
        });
      }
      if (rightArrow) {
        rightArrow.addEventListener('click', () => {
          viewOffsetX += VIEW_STEP;
          applyCameraLook();
          updateAllHtmlLabels();
        });
      }

      drawingArea.addEventListener('pointerdown', onRunDirPointerDown);
      document.addEventListener('pointermove', onRunDirPointerMove);
      document.addEventListener('pointerup', onRunDirPointerUp);
      document.addEventListener('pointercancel', onRunDirPointerUp);

      updateDimensions();
      updateRunDirectionArrow();
      frameCamera();
      animate();
      pushHistory();
    }

    function onResize() {
      camera.aspect = DRAW_WIDTH / DRAW_HEIGHT;
      camera.updateProjectionMatrix();
      updateAllHtmlLabels();
    }

    function createWireframeBox() {
      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      const geometry = new THREE.BoxGeometry(width, thickness, length);
      const edges = new THREE.EdgesGeometry(geometry);
      const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
      wireframeBox = new THREE.LineSegments(edges, lineMaterial);
      scene.add(wireframeBox);
    }

    function updateBox() {
      scene.remove(wireframeBox);
      createWireframeBox();
      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);
      updateDimensions();
      rebuildLinesFromModel();
      updateRunDirectionArrow();
      frameCamera();
    }

    function updateZoom() {
      const minDist = 50;
      const maxDist = 400;

      const sliderMin = parseFloat(zoomSlider.min);
      const sliderMax = parseFloat(zoomSlider.max);
      const sliderVal = parseFloat(zoomSlider.value);
      const t = (sliderVal - sliderMin) / (sliderMax - sliderMin);

      const dist = maxDist - t * (maxDist - minDist);

      const target = new THREE.Vector3(viewOffsetX, viewOffsetY, 0);
      const dir = camera.position.clone().sub(target).normalize();
      camera.position.copy(target.clone().add(dir.multiplyScalar(dist)));
      applyCameraLook();

      updateAllHtmlLabels();
    }

    function frameCamera() {
      const w = parseInches(widthInput.value)  || 1;
      const l = parseInches(lengthInput.value) || 1;

      const diag   = Math.sqrt(w * w + l * l);
      const radius = diag / 2;

      const fovRad = THREE.MathUtils.degToRad(camera.fov);
      const dist   = (radius / Math.sin(fovRad / 2)) * 1.2;

      const dir = new THREE.Vector3(1, 1, 1).normalize();
      const target = new THREE.Vector3(viewOffsetX, viewOffsetY, 0);
      camera.position.copy(target.clone().add(dir.multiplyScalar(dist)));
      applyCameraLook();

      updateAllHtmlLabels();
    }

    function updateDimensions() {
      if (!dimensionGroup) return;

      for (let i = htmlLabels.length - 1; i >= 0; i--) {
        if (htmlLabels[i].styleKey === 'dimW' || htmlLabels[i].styleKey === 'dimL') {
          htmlLabels[i].el.remove();
          htmlLabels.splice(i, 1);
        }
      }

      dimensionGroup.clear();

      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      if (!width || !length) return;

      const y = thickness + 0.5;
      const offset = 3;

      const arrowChar = SYMBOL_STYLES.arrowhead;
      const tex = getSymbolTexture(arrowChar);
      const arrowSize = 1.2;

      /* WIDTH dimension on top – WITH small ARROWS */
      const wStart = new THREE.Vector3(-width / 2, y, -length / 2 - offset);
      const wEnd   = new THREE.Vector3( width / 2, y, -length / 2 - offset);
      const wGeo   = new THREE.BufferGeometry().setFromPoints([wStart, wEnd]);
      const wMat   = new THREE.LineBasicMaterial({ color: 0x000000 });
      const wLine  = new THREE.Line(wGeo, wMat);
      dimensionGroup.add(wLine);

      const wMid = new THREE.Vector3().addVectors(wStart, wEnd).multiplyScalar(0.5);
      addLabel(formatInchesWithQuote(width), wMid, false, 'dimW', wStart, wEnd, false);

      const wDir = new THREE.Vector3().subVectors(wEnd, wStart).normalize();
      const insetW = 0.6;

      const matWStart = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const spriteWStart = new THREE.Sprite(matWStart);
      spriteWStart.position.copy(wStart.clone().add(wDir.clone().multiplyScalar(insetW)));
      spriteWStart.scale.set(arrowSize, arrowSize, arrowSize);
      spriteWStart.material.rotation = Math.PI;
      dimensionGroup.add(spriteWStart);

      const matWEnd = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const spriteWEnd = new THREE.Sprite(matWEnd);
      spriteWEnd.position.copy(wEnd.clone().add(wDir.clone().multiplyScalar(-insetW)));
      spriteWEnd.scale.set(arrowSize, arrowSize, arrowSize);
      spriteWEnd.material.rotation = 0;
      dimensionGroup.add(spriteWEnd);

      /* LENGTH dimension on side – NO small arrows */
      const lStart = new THREE.Vector3(width / 2 + offset, y, -length / 2);
      const lEnd   = new THREE.Vector3(width / 2 + offset, y,  length / 2);
      const lGeo   = new THREE.BufferGeometry().setFromPoints([lStart, lEnd]);
      const lMat   = new THREE.LineBasicMaterial({ color: 0x000000 });
      const lLine  = new THREE.Line(lGeo, lMat);
      dimensionGroup.add(lLine);

      const lMid = new THREE.Vector3().addVectors(lStart, lEnd).multiplyScalar(0.5);
      addLabel(formatInchesWithQuote(length), lMid, true, 'dimL', lStart, lEnd, false);
    }

    function updateRunDirectionArrow() {
      if (!runDirectionGroup) return;
      runDirectionGroup.clear();
      runDirectionSprite = null;
      runDirectionSprites = [];
      runDirectionCenter3D = null;

      const mode = document.getElementById('runDirection').value;
      if (mode === 'none') return;

      const width     = parseInches(widthInput.value);
      const length    = parseInches(lengthInput.value);
      const thickness = parseInches(thicknessInput.value);

      if (!width || !length) return;

      const arrowChar = SYMBOL_STYLES.arrowhead;
      const tex = getSymbolTexture(arrowChar);

      const y = thickness + 1.0;
      const offsetZ = 3;
      const baseAlong = 0.8;

      const rightPos = new THREE.Vector3(
        width / 2 - baseAlong,
        y,
        -length / 2 - offsetZ
      );

      const size = 3.0;
      const rotRad = THREE.MathUtils.degToRad(runDirectionRotationDeg || 0);

      const matRight = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const spriteRight = new THREE.Sprite(matRight);
      spriteRight.position.copy(rightPos);
      spriteRight.scale.set(size, size, size);
      spriteRight.material.rotation = rotRad;
      runDirectionGroup.add(spriteRight);

      runDirectionSprite = spriteRight;
      runDirectionSprites = [spriteRight];
      runDirectionCenter3D = rightPos.clone();
    }

    function addYtoYLine() {
      const distanceFromX = parseInches(distanceFromXInput.value);
      const lineType      = document.getElementById('lineType').value;
      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      if (!cubeWidth || !cubeLength || isNaN(distanceFromX)) return;

      const lineLengthY = cubeLength;
      lineLengthYInput.value = formatInchesWithQuote(cubeLength);

      linesModel.push({
        kind: 'Y',
        lineLength: lineLengthY,
        distance: distanceFromX,
        lineType
      });

      const startX = -cubeWidth / 2 + distanceFromX;
      const startY = 0.5;
      const startZ = -cubeLength / 2;

      const start = new THREE.Vector3(startX, startY, startZ);
      const end   = new THREE.Vector3(startX, startY, startZ + lineLengthY);

      const flipLabel = true;
      drawLineAndExtras(start, end, lineType, flipLabel, 'Y');
      pushHistory();
    }

    function addXtoXLine() {
      const distanceFromY = parseInches(distanceFromYInput.value);
      const lineType      = document.getElementById('lineType').value;
      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      if (!cubeWidth || !cubeLength || isNaN(distanceFromY)) return;

      const lineLengthX = cubeWidth;
      lineLengthXInput.value = formatInchesWithQuote(cubeWidth);

      linesModel.push({
        kind: 'X',
        lineLength: lineLengthX,
        distance: distanceFromY,
        lineType
      });

      const startX = -cubeWidth / 2;
      const startY = 0.5;
      const startZ = -cubeLength / 2 + distanceFromY;

      const start = new THREE.Vector3(startX, startY, startZ);
      const end   = new THREE.Vector3(startX + lineLengthX, startY, startZ);

      const flipLabel = false;
      drawLineAndExtras(start, end, lineType, flipLabel, 'X');
      pushHistory();
    }

    function rebuildLinesFromModel() {
      lineGroup.clear();
      shapeGroup.clear();
      for (let i = htmlLabels.length - 1; i >= 0; i--) {
        if (htmlLabels[i].styleKey !== 'dimW' && htmlLabels[i].styleKey !== 'dimL') {
          htmlLabels[i].el.remove();
          htmlLabels.splice(i, 1);
        }
      }

      const cubeWidth  = parseInches(widthInput.value);
      const cubeLength = parseInches(lengthInput.value);

      linesModel.forEach(l => {
        let start, end, flipLabel = false;

        if (l.kind === 'Y') {
          l.lineLength = cubeLength;

          const startX = -cubeWidth / 2 + l.distance;
          const startY = 0.5;
          const startZ = -cubeLength / 2;

          start = new THREE.Vector3(startX, startY, startZ);
          end   = new THREE.Vector3(startX, startY, startZ + l.lineLength);

          flipLabel = true;
          drawLineAndExtras(start, end, l.lineType, flipLabel, 'Y');
        } else if (l.kind === 'X') {
          l.lineLength = cubeWidth;

          const startX = -cubeWidth / 2;
          const startY = 0.5;
          const startZ = -cubeLength / 2 + l.distance;

          start = new THREE.Vector3(startX, startY, startZ);
          end   = new THREE.Vector3(startX + l.lineLength, startY, startZ);

          flipLabel = false;
          drawLineAndExtras(start, end, l.lineType, flipLabel, 'X');
        }
      });

      if (linesModel.some(l => l.kind === 'Y')) {
        lineLengthYInput.value = formatInchesWithQuote(cubeLength);
      }
      if (linesModel.some(l => l.kind === 'X')) {
        lineLengthXInput.value = formatInchesWithQuote(cubeWidth);
      }
    }

    function drawLineAndExtras(start, end, lineType, flipLabel, orientation) {
      const isSymbolStyle = Object.prototype.hasOwnProperty.call(SYMBOL_STYLES, lineType);

      if (!isSymbolStyle) {
        if (lineType in LINE_STYLES) {
          const styled = drawStyledLine(start, end, lineType);
          lineGroup.add(styled);
        } else {
          const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
          const mat = new THREE.LineBasicMaterial({ color: 0x000000 });
          lineGroup.add(new THREE.Line(geo, mat));
        }
      }

      if (isSymbolStyle) {
        addSymbolLine(lineType, start, end, orientation);
      } else {
        addGroupedShapes(lineType, start.clone(), start.distanceTo(end), isVertical(start, end));
      }

      const vertical = isVertical(start, end);
      const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
      mid.y += 0.01;

      const labelText = getLabelDisplayText(lineType);
      addLabel(labelText, mid, vertical, lineType, start, end, flipLabel);
    }

    function addGroupedShapes(lineType, startPosition, lineLength, isVerticalLine) {
      let shapeCount;
      if (lineType.includes('circle'))      shapeCount = parseInt(lineType.replace('circle',''),10);
      else if (lineType.includes('triangle')) shapeCount = parseInt(lineType.replace('triangle',''),10);
      else if (lineType.includes('square'))   shapeCount = parseInt(lineType.replace('square',''),10);
      else return;

      const groupSize = shapeCount;
      const gapSize   = 1.5;
      const totalGroupSize = groupSize + gapSize;
      const numGroups = Math.floor(lineLength / totalGroupSize);
      const shapeSpacing = 0.9;

      for (let g=0; g<numGroups; g++) {
        const groupStart = g * totalGroupSize;
        for (let i=0; i<shapeCount; i++) {
          const pos = startPosition.clone();
          if (isVerticalLine) pos.z += groupStart + (i * shapeSpacing);
          else                pos.x += groupStart + (i * shapeSpacing);

          let shape;
          if (lineType.includes('circle'))      shape = createCircle();
          else if (lineType.includes('triangle')) shape = createTriangle();
          else if (lineType.includes('square'))   shape = createSquare();

          shape.position.copy(pos);
          shapeGroup.add(shape);
        }
      }
      scene.add(shapeGroup);
    }

    function createCircle() {
      const geometry = new THREE.CircleGeometry(0.2, 32);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }
    function createTriangle() {
      const geometry = new THREE.ConeGeometry(0.3, 0.3, 3);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }
    function createSquare() {
      const geometry = new THREE.PlaneGeometry(0.5, 0.2);
      const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = -Math.PI/2;
      return mesh;
    }

    const addTextButton = document.getElementById('addTextButton');
    const textSizeInput = document.getElementById('textSize');

    addTextButton.addEventListener('click', function() {
      const text = document.getElementById('textInput').value;
      const textSize = parseInt(textSizeInput.value,10);
      if (text) {
        const c = document.createElement('div');
        c.className = 'textContainer';
        c.style.left = '100px';
        c.style.top  = '100px';

        const el = document.createElement('div');
        el.className = 'textElement';
        el.style.fontSize = `${textSize}px`;
        el.textContent = text;
        c.appendChild(el);

        document.body.appendChild(c);
        enableDrag(c);
        selectElement(c);
        pushHistory();
      }
    });

    function selectElement(element) {
      if (selectedElement) selectedElement.classList.remove('selected');
      selectedElement = element;
      selectedElement.classList.add('selected');

      if (selectedElement.classList.contains('textContainer')) {
        const px = parseInt(getComputedStyle(selectedElement.querySelector('.textElement')).fontSize,10);
        document.getElementById('textSize').value = px;
      } else if (selectedElement.classList.contains('icon')) {
        document.getElementById('iconSize').value = parseInt(selectedElement.style.width,10);
      }
    }

    function clearSelection() {
      if (selectedElement) {
        selectedElement.classList.remove('selected');
        selectedElement = null;
        rotationAngle = 0;
      }
    }

    document.addEventListener('pointerdown', (e) => {
      const onDraggable = e.target.closest('.textContainer, .icon');
      const onControls  = e.target.closest('#controls, #iconUploader, #textControls, #labelControls, #actionBar');
      if (!onDraggable && !onControls) clearSelection();
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') clearSelection();
    });

    document.getElementById('rotateTextButton').addEventListener('click', function() {
      if (selectedElement) {
        rotationAngle = (rotationAngle + 5) % 360;
        selectedElement.style.transform = `rotate(${rotationAngle}deg)`;
        pushHistory();
      }
    });

    document.getElementById('textSize').addEventListener('change', function(e) {
      if (selectedElement && selectedElement.classList.contains('textContainer')) {
        selectedElement.querySelector('.textElement').style.fontSize = `${e.target.value}px`;
        pushHistory();
      }
    });

    const iconUploader = document.getElementById('uploadIcon');
    const iconSizeInput = document.getElementById('iconSize');
    iconUploader.addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          const c = document.createElement('div');
          c.className = 'icon';
          c.style.width  = `${iconSizeInput.value}px`;
          c.style.height = `${iconSizeInput.value}px`;
          c.style.left   = '120px';
          c.style.top    = '120px';

          const img = document.createElement('img');
          img.src = e.target.result;
          c.appendChild(img);

          document.body.appendChild(c);
          enableDrag(c);
          selectElement(c);
          pushHistory();
        };
        reader.readAsDataURL(file);
      }
    });

    document.getElementById('rotateIconButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        rotationAngle = (rotationAngle + 5) % 360;
        selectedElement.style.transform = `rotate(${rotationAngle}deg)`;
        pushHistory();
      }
    });

    iconSizeInput.addEventListener('change', function(e) {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        selectedElement.style.width  = `${e.target.value}px`;
        selectedElement.style.height = `${e.target.value}px`;
        pushHistory();
      }
    });

    function enableDrag(element) {
      let isDown = false;
      let offsetX = 0, offsetY = 0;
      let activePointerId = null;

      function onPointerMove(e) {
        if (!isDown || e.pointerId !== activePointerId) return;
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        element.style.left = x + 'px';
        element.style.top  = y + 'px';
      }

      function onPointerUp(e) {
        if (e.pointerId !== activePointerId) return;
        isDown = false;
        activePointerId = null;
        element.classList.remove('dragging');

        document.removeEventListener('pointermove', onPointerMove);
        document.removeEventListener('pointerup', onPointerUp);
        document.removeEventListener('pointercancel', onPointerUp);
        document.removeEventListener('pointerleave', onPointerUp);
        try { element.releasePointerCapture(e.pointerId); } catch(_) {}

        pushHistory();
      }

      element.addEventListener('pointerdown', (e) => {
        selectElement(element);
        const rect = element.getBoundingClientRect();
        offsetX = e.clientX - rect.left;
        offsetY = e.clientY - rect.top;

        isDown = true;
        activePointerId = e.pointerId;
        element.classList.add('dragging');

        try { element.setPointerCapture(e.pointerId); } catch(_) {}

        document.addEventListener('pointermove', onPointerMove);
        document.addEventListener('pointerup', onPointerUp);
        document.addEventListener('pointercancel', onPointerUp);
        document.addEventListener('pointerleave', onPointerUp);

        e.preventDefault();
      });

      element.addEventListener('dragstart', (e) => e.preventDefault());
    }

    document.getElementById('deleteTextButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('textContainer')) {
        selectedElement.remove(); selectedElement = null;
        pushHistory();
      }
    });
    document.getElementById('deleteIconButton').addEventListener('click', function() {
      if (selectedElement && selectedElement.classList.contains('icon')) {
        selectedElement.remove(); selectedElement = null;
        pushHistory();
      }
    });

    const clearButton = document.getElementById('clearButton');
    clearButton.addEventListener('click', function() {
      document.querySelectorAll('.icon').forEach(icon => icon.remove());
      document.querySelectorAll('.textContainer').forEach(text => text.remove());

      shapeGroup.clear();
      lineGroup.clear();
      dimensionGroup.clear();
      if (runDirectionGroup) runDirectionGroup.clear();
      clearHtmlLabels();
      linesModel.length = 0;

      scene.clear();
      createWireframeBox();
      scene.add(lineGroup);
      scene.add(shapeGroup);
      scene.add(dimensionGroup);
      scene.add(runDirectionGroup);

      document.getElementById('runDirection').value = 'none';
      runDirectionRotationDeg = 0;
      runDirectionSprites = [];
      runDirectionCenter3D = null;

      // reset camera offset when clearing
      viewOffsetX = 0;
      viewOffsetY = -6;

      updateDimensions();
      updateRunDirectionArrow();
      clearSelection();
      frameCamera();
      pushHistory();
    });

    function setupHistoryButtons() {
      document.getElementById('undoButton').addEventListener('click', undo);
      document.getElementById('redoButton').addEventListener('click', redo);
    }

    function setupSaveLoadButtons() {
      const saveBtn   = document.getElementById('saveStateButton');
      const loadBtn   = document.getElementById('loadStateButton');
      const loadInput = document.getElementById('loadStateInput');
      const specBtn   = document.getElementById('exportSpecJsonButton');

      saveBtn.addEventListener('click', () => {
        const stateJSON = serializeState();
        const blob = new Blob([stateJSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'panel_drawing_state.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });

      loadBtn.addEventListener('click', () => {
        loadInput.value = '';
        loadInput.click();
      });

      loadInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const text = ev.target.result;
          restoreState(text);
          pushHistory();
        };
        reader.readAsText(file);
      });

      specBtn.addEventListener('click', () => {
        const specJSON = buildSpecJson();
        const blob = new Blob([specJSON], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'panel_spec.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }

    function buildSpecJson() {
      return JSON.stringify({
        version: 1,
        panel: {
          width:      parseInches(widthInput.value),
          length:     parseInches(lengthInput.value),
          thickness:  parseInches(thicknessInput.value),
          partNumber: partNumberInput.value || ''
        },
        runDirection: document.getElementById('runDirection').value,
        runDirectionRotationDeg,
        notes: notesInput.value || '',
        lines: linesModel.map(l => ({
          kind:       l.kind,
          distance:   l.distance,
          lineLength: l.lineLength,
          styleKey:   l.lineType,
          label:      STYLE_LABELS[l.lineType] || l.lineType
        }))
      }, null, 2);
    }

    function serializeState() {
      return JSON.stringify({
        dims: {
          width:      parseInches(widthInput.value),
          length:     parseInches(lengthInput.value),
          thickness:  parseInches(thicknessInput.value),
          partNumber: partNumberInput.value || ''
        },
        lines: linesModel.slice(),
        runDirection: document.getElementById('runDirection').value,
        runDirectionRotationDeg,
        notes: notesInput.value || '',
        texts: Array.from(document.querySelectorAll('.textContainer')).map(c => {
          const el = c.querySelector('.textElement');
          return {
            text: el.textContent,
            fontSize: parseInt(getComputedStyle(el).fontSize,10),
            left: c.style.left || '0px',
            top: c.style.top || '0px',
            rotation: getRotationDeg(c.style.transform || '')
          };
        }),
        icons: Array.from(document.querySelectorAll('.icon')).map(c => {
          const img = c.querySelector('img');
          return {
            src: img.src,
            width: parseInt(c.style.width,10) || 100,
            height: parseInt(c.style.height,10) || 100,
            left: c.style.left || '0px',
            top: c.style.top || '0px',
            rotation: getRotationDeg(c.style.transform || '')
          };
        })
      });
    }

    function getRotationDeg(transformStr) {
      const m = /rotate\(([-\d.]+)deg\)/.exec(transformStr);
      return m ? parseFloat(m[1]) : 0;
    }

    function pushHistory() {
      redoStack.length = 0;
      history.push(serializeState());
      if (history.length > 50) history.shift();
    }

    function undo() {
      if (history.length < 2) return;
      const current = history.pop();
      redoStack.push(current);
      const prev = history[history.length - 1];
      restoreState(prev);
    }

    function redo() {
      if (redoStack.length === 0) return;
      const state = redoStack.pop();
      history.push(state);
      restoreState(state);
    }

    function restoreState(stateJSON) {
      const state = JSON.parse(stateJSON);

      widthInput.value     = formatInchesWithQuote(state.dims.width);
      lengthInput.value    = formatInchesWithQuote(state.dims.length);
      thicknessInput.value = formatInchesWithQuote(state.dims.thickness);
      if (state.dims.partNumber !== undefined) {
        partNumberInput.value = state.dims.partNumber;
      } else {
        partNumberInput.value = '';
      }
      notesInput.value     = state.notes || '';

      const runDirSelect = document.getElementById('runDirection');
      if (state.runDirection) {
        runDirSelect.value = state.runDirection;
      } else {
        runDirSelect.value = 'none';
      }

      if (typeof state.runDirectionRotationDeg === 'number') {
        runDirectionRotationDeg = state.runDirectionRotationDeg;
      } else {
        switch (runDirSelect.value) {
          case 'xPlus':  runDirectionRotationDeg = 0;   break;
          case 'xMinus': runDirectionRotationDeg = 180; break;
          case 'yPlus':  runDirectionRotationDeg = 90;  break;
          case 'yMinus': runDirectionRotationDeg = -90; break;
          default:       runDirectionRotationDeg = 0;
        }
      }

      // reset view offsets on restore so drawing recenters
      viewOffsetX = 0;
      viewOffsetY = -6;

      linesModel.length = 0;
      state.lines.forEach(l => linesModel.push(l));

      updateBox();

      document.querySelectorAll('.icon').forEach(n => n.remove());
      document.querySelectorAll('.textContainer').forEach(n => n.remove());

      state.texts.forEach(t => {
        const c = document.createElement('div');
        c.className = 'textContainer';
        c.style.left = t.left;
        c.style.top  = t.top;
        c.style.transform = `rotate(${t.rotation}deg)`;

        const el = document.createElement('div');
        el.className = 'textElement';
        el.textContent = t.text;
        el.style.fontSize = `${t.fontSize}px`;
        c.appendChild(el);

        document.body.appendChild(c);
        enableDrag(c);
      });

      state.icons.forEach(i => {
        const c = document.createElement('div');
        c.className = 'icon';
        c.style.left   = i.left;
        c.style.top    = i.top;
        c.style.width  = `${i.width}px`;
        c.style.height = `${i.height}px`;
        c.style.transform = `rotate(${i.rotation}deg)`;

        const img = c.querySelector('img') || document.createElement('img');
        img.src = i.src;
        if (!c.contains(img)) c.appendChild(img);

        document.body.appendChild(c);
        enableDrag(c);
      });

      clearSelection();
      renderer.render(scene, camera);
      updateAllHtmlLabels();
    }

    function getRunDirectionScreenCenter() {
      if (!runDirectionCenter3D) return null;
      const rect = drawingArea.getBoundingClientRect();
      const pos = runDirectionCenter3D.clone();
      pos.project(camera);
      const x = (pos.x + 1) / 2 * rect.width;
      const y = (-pos.y + 1) / 2 * rect.height;
      return { x, y };
    }

    function onRunDirPointerDown(e) {
      const mode = document.getElementById('runDirection').value;
      if (mode === 'none') return;
      if (!runDirectionSprites || runDirectionSprites.length === 0) return;

      const rect = drawingArea.getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;

      let minDist = Infinity;

      runDirectionSprites.forEach(sprite => {
        const pos = sprite.position.clone().project(camera);
        const sx = (pos.x + 1) / 2 * rect.width;
        const sy = (-pos.y + 1) / 2 * rect.height;
        const dx = px - sx;
        const dy = py - sy;
        const d = Math.sqrt(dx*dx + dy*dy);
        if (d < minDist) minDist = d;
      });

      if (minDist > 40) return;

      const center = getRunDirectionScreenCenter();
      if (!center) return;

      const dx0 = px - center.x;
      const dy0 = py - center.y;
      dragStartAngleScreen = Math.atan2(dy0, dx0);
      dragStartRotationDeg = runDirectionRotationDeg || 0;
      isRotatingRunDir = true;
      e.preventDefault();
    }

    function onRunDirPointerMove(e) {
      if (!isRotatingRunDir) return;
      const rect = drawingArea.getBoundingClientRect();
      const center = getRunDirectionScreenCenter();
      if (!center) return;

      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const dx = px - center.x;
      const dy = py - center.y;

      const angle = Math.atan2(dy, dx);
      let deltaRad = angle - dragStartAngleScreen;

      if (deltaRad > Math.PI)  deltaRad -= 2 * Math.PI;
      if (deltaRad < -Math.PI) deltaRad += 2 * Math.PI;

      let deltaDeg = THREE.MathUtils.radToDeg(deltaRad);
      let total = dragStartRotationDeg + deltaDeg;

      const snapped = Math.round(total / 15) * 15;
      runDirectionRotationDeg = snapped;

      updateRunDirectionArrow();
    }

    function onRunDirPointerUp(e) {
      if (!isRotatingRunDir) return;
      isRotatingRunDir = false;
      pushHistory();
    }

    const exportButton = document.getElementById('exportButton');
    exportButton.addEventListener('click', function() {
      renderer.render(scene, camera);

      const finalCanvas  = document.createElement('canvas');
      const finalContext = finalCanvas.getContext('2d');

      finalCanvas.width  = DRAW_WIDTH;
      finalCanvas.height = DRAW_HEIGHT;

      finalContext.drawImage(renderer.domElement, 0, 0);

      const areaRect = drawingArea.getBoundingClientRect();

      const icons = document.querySelectorAll('.icon img');
      icons.forEach(icon => {
        const r = icon.getBoundingClientRect();
        const x = r.left - areaRect.left;
        const y = r.top  - areaRect.top;
        finalContext.drawImage(icon, x, y, r.width, r.height);
      });

      const texts = document.querySelectorAll('.textElement');
      texts.forEach(text => {
        const r = text.getBoundingClientRect();
        const x = r.left - areaRect.left;
        const y = r.top  - areaRect.top;
        const sizePx = parseInt(getComputedStyle(text).fontSize,10);
        const lineHeight = Math.round(sizePx * 1.2);
        finalContext.font = `${sizePx}px Arial`;
        finalContext.fillStyle = '#000';

        const lines = (text.textContent || '').split(/\r?\n/);
        let yy = y + sizePx;
        lines.forEach((ln) => {
          finalContext.fillText(ln, x, yy);
          yy += lineHeight;
        });
      });

      htmlLabels.forEach(lbl => {
        const mid = lbl.pos3.clone();
        mid.project(camera);
        const x = (mid.x + 1) / 2 * finalCanvas.width;
        const y = (-mid.y + 1) / 2 * finalCanvas.height;

        const s = lbl.start3.clone().project(camera);
        const e = lbl.end3.clone().project(camera);
        const sx = (s.x + 1) / 2 * finalCanvas.width;
        const sy = (-s.y + 1) / 2 * finalCanvas.height;
        const ex = (e.x + 1) / 2 * finalCanvas.width;
        const ey = (-e.y + 1) / 2 * finalCanvas.height;

        let angleRad = Math.atan2(ey - sy, ex - sx);
        if (lbl.flipLabel) angleRad += Math.PI;

        if (angleRad > Math.PI)  angleRad -= 2 * Math.PI;
        if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
        if (angleRad >  Math.PI / 2)  angleRad -= Math.PI;
        if (angleRad < -Math.PI / 2)  angleRad += Math.PI;

        const coreText = lbl.text || '';
        const padded = '  ' + coreText + '  ';

        const fontSize = 14;
        finalContext.font = `${fontSize}px Arial`;
        const metrics = finalContext.measureText(padded);
        const textWidth  = metrics.width;
        const textHeight = fontSize * 1.4;

        if (labelHasBackground(lbl.styleKey)) {
          finalContext.save();
          finalContext.translate(x, y);
          finalContext.rotate(angleRad);
          finalContext.fillStyle = '#ffffff';
          finalContext.fillRect(
            -textWidth / 2 - 4,
            -textHeight / 2 + 2,
            textWidth + 8,
            textHeight
          );
          finalContext.restore();
        }

        finalContext.save();
        finalContext.translate(x, y);
        finalContext.rotate(angleRad);
        finalContext.fillStyle = '#000000';
        finalContext.textAlign = 'center';
        finalContext.textBaseline = 'middle';
        finalContext.fillText(padded, 0, 0);
        finalContext.restore();
      });

      const link = document.createElement('a');
      const rawPart = (partNumberInput.value || '').trim();
      const safeName = rawPart
        ? rawPart.replace(/[^a-z0-9_\-]+/gi, '_')
        : 'scene_export';
      link.href = finalCanvas.toDataURL('image/jpeg');
      link.download = safeName + '.jpeg';
      link.click();
    });

    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
      updateAllHtmlLabels();
    }

    init();
  

// -------------------- DB (Postgres via Render) --------------------
(function setupDbUI(){
  const recordsList = document.getElementById("recordsList");
  const dbSearchInput = document.getElementById("dbSearchInput");
  const refreshDbBtn = document.getElementById("refreshDbBtn");
  const dbSaveBtn = document.getElementById("dbSaveBtn");
  const dbLoadBtn = document.getElementById("dbLoadBtn");

  // These are already defined earlier in your code:
  // const partNumberInput = document.getElementById('partNumber');
  // const notesInput = document.getElementById('notes');

  if (!recordsList || !dbSearchInput || !refreshDbBtn || !dbSaveBtn || !dbLoadBtn) {
    console.warn("DB UI elements missing - skipping DB UI setup.");
    return;
  }

  let selectedPartFromList = null;

  async function fetchRecords() {
    try {
      const q = (dbSearchInput.value || "").trim();
      const url = q ? `/api/drawings?q=${encodeURIComponent(q)}` : `/api/drawings`;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch records");
      const rows = await res.json();

      recordsList.innerHTML = "";
      rows.forEach(r => {
        const row = document.createElement("div");
        row.style.display = "flex";
        row.style.justifyContent = "space-between";
        row.style.alignItems = "center";
        row.style.padding = "4px 0";
        row.style.borderBottom = "1px solid #eee";
        row.style.gap = "8px";

        const left = document.createElement("button");
        left.textContent = r.part_number;
        left.style.textAlign = "left";
        left.style.flex = "1";
        left.style.padding = "6px 8px";
        left.style.borderRadius = "8px";
        left.style.border = "1px solid #ddd";
        left.style.background = "#fff";
        left.onclick = () => {
          selectedPartFromList = r.part_number;
          partNumberInput.value = r.part_number;
        };

        const editBtn = document.createElement("button");
        editBtn.textContent = "Edit";
        editBtn.style.padding = "6px 8px";
        editBtn.onclick = async () => {
          selectedPartFromList = r.part_number;
          const resp = await fetch(`/api/drawings/${encodeURIComponent(r.part_number)}`);
          if (!resp.ok) return alert("Not found.");
          const data = await resp.json();

          // Load state into your app:
          restoreState(JSON.stringify(data.state_json));

          // Restore fields:
          partNumberInput.value = data.part_number;
          notesInput.value = data.notes || "";

          if (typeof pushHistory === "function") pushHistory();
        };

        const delBtn = document.createElement("button");
        delBtn.textContent = "Delete";
        delBtn.style.padding = "6px 8px";
        delBtn.onclick = async () => {
          if (!confirm(`Delete ${r.part_number}?`)) return;
          const resp = await fetch(`/api/drawings/${encodeURIComponent(r.part_number)}`, { method: "DELETE" });
          if (!resp.ok) return alert("Delete failed.");
          if (selectedPartFromList === r.part_number) selectedPartFromList = null;
          await fetchRecords();
        };

        const right = document.createElement("div");
        right.style.display = "flex";
        right.style.gap = "6px";
        right.append(editBtn, delBtn);

        row.append(left, right);
        recordsList.appendChild(row);
      });
    } catch (e) {
      console.error(e);
      // Don't spam alerts; just show something small.
      recordsList.innerHTML = '<div style="padding:6px; color:#b00;">DB not reachable yet.</div>';
    }
  }

  dbSearchInput.addEventListener("input", () => fetchRecords());
  refreshDbBtn.addEventListener("click", () => fetchRecords());

  dbSaveBtn.addEventListener("click", async () => {
    const pn = (partNumberInput.value || "").trim();
    if (!pn) return alert("Enter Part Number first.");
    try {
      const stateJson = JSON.parse(serializeState()); // your existing function returns JSON string
      const payload = { partNumber: pn, notes: notesInput.value || "", stateJson };

      const res = await fetch("/api/drawings", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await res.json().catch(() => ({}));
      if (!res.ok) return alert(data.error || "Save failed.");

      await fetchRecords();
      alert("Saved.");
    } catch (e) {
      console.error(e);
      alert("Save failed (see console).");
    }
  });

  dbLoadBtn.addEventListener("click", async () => {
    const pn = (partNumberInput.value || selectedPartFromList || "").trim();
    if (!pn) return alert("Select or type a Part Number to load.");
    const res = await fetch(`/api/drawings/${encodeURIComponent(pn)}`);
    if (!res.ok) return alert("Not found.");
    const data = await res.json();

    restoreState(JSON.stringify(data.state_json));
    partNumberInput.value = data.part_number;
    notesInput.value = data.notes || "";

    if (typeof pushHistory === "function") pushHistory();
  });

  // Initial load (after page init)
  window.addEventListener("load", () => fetchRecords());
})();

</script>
</body>
</html>
